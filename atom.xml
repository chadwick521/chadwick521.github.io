<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhaoyh&#39;s blog</title>
  
  
  <link href="http://blog.zhaoyh.com.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.zhaoyh.com.cn/"/>
  <updated>2023-06-07T06:05:56.902Z</updated>
  <id>http://blog.zhaoyh.com.cn/</id>
  
  <author>
    <name>zhaoyh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>a test for new</title>
    <link href="http://blog.zhaoyh.com.cn/2023/06/07/a-test-for-new/"/>
    <id>http://blog.zhaoyh.com.cn/2023/06/07/a-test-for-new/</id>
    <published>2023-06-07T06:05:56.000Z</published>
    <updated>2023-06-07T06:05:56.902Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库开发入门级教程</title>
    <link href="http://blog.zhaoyh.com.cn/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.zhaoyh.com.cn/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%99%E7%A8%8B/</id>
    <published>2023-05-12T08:04:38.000Z</published>
    <updated>2023-07-14T10:17:13.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-数据库定义"><a href="#1-1-数据库定义" class="headerlink" title="1.1 数据库定义"></a>1.1 数据库定义</h4><p>数据是数据库中存储的基本对象，包括数字、图像、音频等形式，在进行逐级抽象后存储在数据库中。数据库是由特定软件，即数据库管理系统（DBMS）搭建、处理、维护的数据及数据间逻辑关系的集合体。它面向多种应用，可以被多个用户、多个应用程序所共享。DBMS是负责数据库搭建、使用和维护的大型系统软件，它对数据进行统一控制管理，以保证数据的完整性和安全性。数据库和数据库管理系统共同组成了数据库系统。</p><span id="more"></span><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCE5cf9dc32b1e3aaeeee15e2cf541e4e90.png" alt="image"></p><h4 id="1-2-发展历程"><a href="#1-2-发展历程" class="headerlink" title="1.2 发展历程"></a>1.2 发展历程</h4><p><img src="https://static.zhaoyh.com.cn/v2_3ca12a6cf02044ca980811e489e23225_img_000.png" alt="image"></p><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCEf7353be5d4dc2e345543891aa1e873a0.png" alt="image"></p><h4 id="1-3-SQL介绍"><a href="#1-3-SQL介绍" class="headerlink" title="1.3 SQL介绍"></a>1.3 SQL介绍</h4><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCE203586ffd917e0ccc9ecb3faa9de7513.png" alt="image"></p><h3 id="2-数据库选型"><a href="#2-数据库选型" class="headerlink" title="2. 数据库选型"></a>2. 数据库选型</h3><h4 id="2-1-按数据结构分类"><a href="#2-1-按数据结构分类" class="headerlink" title="2.1 按数据结构分类"></a>2.1 按数据结构分类</h4><ul><li>传统关系型数据库，保证ACID特性，是当今主流的数据库类型，如Oracle、MySQL、PostgreSQL、SQLite、SQLServer；</li><li>NoSQL数据库，NoSQL即Not Only SQL，NoSQL数据库指那些不使用关系模型、分布式、不保证遵循ACID原型的数据库。列式（HBase、Cassandra、ClickHouse），键值（Redis、Memcached），图数据库（Neo4J，TigerGraph），文档（MongoDB、CouchDB、ElasticSearch），时序（InfluxDB、Prometheus）；</li><li>NewSQL数据库，NoSQL虽然在可扩展性和可用性方面表现优秀，但是无法满足事务一致性的要求。2011年Matthew Aslett提出了“NewSQL”术语用以定义新出现的“可横向扩展的OLTP关系型数据库”。MemSQL、VoltDB、NuoDB、TIDB；</li><li>多模数据库，是一种可以在多个模型中存储和查询数据的数据库，为异构数据提供了较好的解决方案。数据库扩展原有模型的路径主要有四种：新存储方式+新数据模型、原存储方式+新数据模型、新接口+原存储模型、原存储模型；</li></ul><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCEe76288a7b40eb52792f677021edc28f5.png" alt="image"></p><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCE07d121c1aad8080831c21702c1e83661.png" alt="image"></p><h4 id="2-2-按部署模式分类"><a href="#2-2-按部署模式分类" class="headerlink" title="2.2 按部署模式分类"></a>2.2 按部署模式分类</h4><ul><li>本地部署，在物理机、虚拟机上部署，最传统的方式；</li><li>云托管数据库，云服务厂商负责管理与维护基础设施，并提供优化、备份、恢复、监控等全套解决方案。企业用户无需购买服务器、交换机等软硬件，后续也无需投入大量的人力成本去运维，可以更专注于企业的应用开发，如阿里云-RDS-MySQL版、腾讯云MySQL，云托管数据库与开源版数据库相比，是一种“开箱即用、弹性扩展、省钱省力、高度可用”的解决方案；</li><li>云原生数据库，基于云环境设计的新型数据库，天生匹配云环境和分布式事务。其核心是存储与计算分离，同时还具备高性能、高可扩展、一致性、容错、易于管理和多云支持等特性。阿里云PolarDB、腾讯云TDSQL、华为云GaussDB</li></ul><p>上层需求驱动，底层技术支撑，存算分离，优化资源编排，云原生数据库是未来趋势：</p><p>对于非云原生的数据库，大体的迁移步骤可参考下图：</p><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCEe1bf1678ad203d8f414ee067d4a18f02.png" alt="image"></p><h4 id="2-3-按功能分类"><a href="#2-3-按功能分类" class="headerlink" title="2.3 按功能分类"></a>2.3 按功能分类</h4><ul><li>OLTP事务型数据库，主要做实时事务处理，通常对规范化、实时性、稳定性、事务性、一致性、完整性等有要求，比如处理用户基本信息、处理订单合同、处理银行转账业务、企业的ERP系统和OA系统等；</li><li>OLAP分析型数据库，主要来自数据仓库、数据集市或数据湖的数据，主要做历史数据分析，为商业决策提供支持，频率较低地，对大量数据，做读取、聚合、计算、分析，实时性要求不高，对吞吐能力要求较高；</li><li>HTAP混合型数据库，随着数据价值的进一步挖掘，企业对数据库系统也提出了新的要求。现阶段企业为满足交易处理和分析的需求，往往采用OLTP+OLAP的组合方案。但二者之间往往存在时延，无法满足企业实时分析的需求；同时管理两个平台往往需要组建两支团队，运维成本高。 HTAP (Hybrid Transactional&#x2F;Analytical Processing) 混合型数据库基于新的计算存储框架，能够同时支撑OLTP和OLAP场景，避免传统架构中大量数据交互造成的资源浪费和冲突。此外，HTAP基于分布式架构，支持弹性扩容，可按需扩展吞吐或存储，轻松应对高并发、海量数据场景；</li></ul><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCEe4894fb65ec55c99630d1552b25017fc.png" alt="image"></p><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCE3d07cfcdb964f8aa3680f8a9e2e26329.png" alt="image"></p><h3 id="3-数据库连接池"><a href="#3-数据库连接池" class="headerlink" title="3. 数据库连接池"></a>3. 数据库连接池</h3><h4 id="3-1-连接池介绍"><a href="#3-1-连接池介绍" class="headerlink" title="3.1 连接池介绍"></a>3.1 连接池介绍</h4><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。通过释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><p>连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。目前，市面上常见的数据库连接池组件主要有如下几个：</p><ul><li>C3P0，历史悠久，过于复杂，性能差，不推荐使用。由于一度是Hibernate内置的数据库连接池而被开发者熟知，但是由于性能和复杂度，官方已经放弃维护；</li><li>DBCP，依赖Commons-Pool，性能差，属于Apache顶级项目Commons中的核心子项目，但DBCP并不是独立实现连接池功能的，它内部依赖于Commons-Pool项目；</li><li>HikariCP，Spring Boot官方默认连接池；</li><li>Druid，阿里巴巴开源的数据库连接池，深受企业级验证；</li></ul><p>Druid的方案及接入性能对比可参考如下：</p><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCE1d155fb3070155b3e964a578d353cfb2.png" alt="image"></p><p>对于连接池来说，连接池本身的性能消耗在整个调用链路中通常占比不大，连接池的性能关键点是，连接是否LRU的方式重用，是否支持PSCache（PreparedStatementCache）才是性能的关键点。</p><h4 id="3-2-连接池使用案例"><a href="#3-2-连接池使用案例" class="headerlink" title="3.2 连接池使用案例"></a>3.2 连接池使用案例</h4><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCE72abbd13962dc3535648bf9dbcaf8a97.png" alt="image"></p><p>以默认数据库连接池HikariCP为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.hikari.minimum-idle=5</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=10</span><br><span class="line">spring.datasource.hikari.idle-timeout=600000</span><br><span class="line">spring.datasource.hikari.max-lifetime=540000</span><br><span class="line">spring.datasource.hikari.connection-timeout=3000</span><br><span class="line">spring.datasource.hikari.connection-test-query=SELECT 1</span><br></pre></td></tr></table></figure><p>单个配置的含义：</p><ul><li><code>minimum-idle</code>，最小空闲连接数；</li><li><code>maximum-pool-size</code>，最大连接数，包括闲置和使用中的连接；</li><li><code>idle-timeout</code>，连接允许在池中闲置的最长时间；</li><li><code>max-lifetime</code>，池中连接最长生命周期，即最大存活时间；</li><li><code>connection-timeout</code>，等待来自池的连接的最大毫秒数；</li><li><code>connection-test-query</code>，用于测试连接是否可用的查询语句，基本不需要配置；</li></ul><h3 id="4-ORM开发框架"><a href="#4-ORM开发框架" class="headerlink" title="4. ORM开发框架"></a>4. ORM开发框架</h3><h4 id="4-1-JDBC与ORM概念"><a href="#4-1-JDBC与ORM概念" class="headerlink" title="4.1 JDBC与ORM概念"></a>4.1 JDBC与ORM概念</h4><p>JDBC（Java DataBase Connectivity），是Java连接数据库操作的原生接口。JDBC对Java程序员而言是API，为数据库访问提供标准的接口。由各个数据库厂商及第三方中间件厂商依照JDBC规范为数据库的连接提供的标准方法。</p><p><img src="https://static.zhaoyh.com.cn/202206131411437.png" alt="image"></p><p>对象-关系映射（Object-Relational Mapping，简称ORM），ORM框架中是Java面向对象编程的思想完美体现。直白点说，ORM就是将代码里面的Java类与DB中的表进行映射，代码中对相关Java类的操作，即体现为DB中对相关数据库表的操作。</p><p><img src="https://static.zhaoyh.com.cn/202206131358853.png" alt="image"></p><h4 id="4-2-ORM框架选型"><a href="#4-2-ORM框架选型" class="headerlink" title="4.2 ORM框架选型"></a>4.2 ORM框架选型</h4><ul><li>JdbcTemplate，原生模式，需要手写查询结果和Java类的映射；</li><li>MyBatis，类似的框架Mybatis-plus，FastMyBatis，在中文开发界很流行；</li><li>Spring-Data-JPA，全自动框架，一般来讲不需要写任何sql，建表的过程也是全自动的，需要写的话，也可以直接写在注解参数里，同时建表的过程也是全自动的，开发者只需要写好对应的类和相关注解；</li></ul><p>Spring Data Jpa是可以完全与数据库脱钩的，在代码迁移到其他数据库之后，只需要切换对应的Dialect就行了。而MyBatis由于所有SQL都是依赖数据库书写的，所以扩展性，迁移性比较差，则可能需要做更多的工作。</p><p>Spring Data Jpa自动生成的sql比较不符合人们的阅读习惯，而MyBatis的Sql则与开发的开发习惯结合较密切，因此在出了问题debug的时候， MyBatis会方便一些。</p><h4 id="4-3-Spring-Data-Jpa接入流程"><a href="#4-3-Spring-Data-Jpa接入流程" class="headerlink" title="4.3 Spring Data Jpa接入流程"></a>4.3 Spring Data Jpa接入流程</h4><p>首先添加依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置文件引入数据库链接信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://xxx/YourDB?useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.datasource.username=xx</span><br><span class="line">spring.datasource.password=xx</span><br></pre></td></tr></table></figure><p>添加实体类，并制定数据表名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user_info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再新建一个操作数据的<code>Repository</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;UserInfo, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，直接操作这个Repository对该表进行增删改查操作即可。JPA也提供了对应的接口：</p><p><img src="https://static.zhaoyh.com.cn/WEBRESOURCEec5ca2510fd9f842e68fce15ce2c286d.png" alt="image"></p><h3 id="5-数据库与大数据技术"><a href="#5-数据库与大数据技术" class="headerlink" title="5. 数据库与大数据技术"></a>5. 数据库与大数据技术</h3><p>以Hadoop为代表的大数据技术以低成本的方式提供海量数据的开发和运行处理，但缺点是结构化能力较差，早期不支持SQL语句解析。随着大数据技术发展，基于Hadoop的数仓工具Hive开始提供SQL查询功能，但整体性能较差。随后支持SQL查询的工具（如Spark SQL）开始涌现，大数据技术的分析处理能力提升，结构化趋势明显。另一方面，数据库天然具备强结构化能力，尤其关系型数据库原生支持SQL查询，但早期存储成本高，对海量数据的支持能力不足。但随着对象存储（OSS）被广泛应用，其低成本、高可用、数据持久及按需付费的特点，让数据库产品能够应对轻体量的大数据场景。由此，随着数据技术的发展创新，数据库与大数据技术的边界不断模糊，二者互相延伸。我们认为传统大数据技术有着更为丰富的生态，但是对技术要求较高，相比较而言，从仓向湖的延伸路线，更适合传统企业和中小企业。</p><p>数据库与大数据技术边界不断模糊，呈现融合趋势。</p><p><img src="https://static.zhaoyh.com.cn/v2_93bf1c4ad26540e18920c1e7f7dd0f4d_img_000.png" alt="image"></p><blockquote><p>以上内容就是关于数据库开发入门级教程的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;h4 id=&quot;1-1-数据库定义&quot;&gt;&lt;a href=&quot;#1-1-数据库定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 数据库定义&quot;&gt;&lt;/a&gt;1.1 数据库定义&lt;/h4&gt;&lt;p&gt;数据是数据库中存储的基本对象，包括数字、图像、音频等形式，在进行逐级抽象后存储在数据库中。数据库是由特定软件，即数据库管理系统（DBMS）搭建、处理、维护的数据及数据间逻辑关系的集合体。它面向多种应用，可以被多个用户、多个应用程序所共享。DBMS是负责数据库搭建、使用和维护的大型系统软件，它对数据进行统一控制管理，以保证数据的完整性和安全性。数据库和数据库管理系统共同组成了数据库系统。&lt;/p&gt;</summary>
    
    
    
    <category term="基础服务" scheme="http://blog.zhaoyh.com.cn/categories/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="MyBatis" scheme="http://blog.zhaoyh.com.cn/tags/MyBatis/"/>
    
    <category term="数据库" scheme="http://blog.zhaoyh.com.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="大数据" scheme="http://blog.zhaoyh.com.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊单元测试</title>
    <link href="http://blog.zhaoyh.com.cn/2023/02/20/%E8%81%8A%E4%B8%80%E8%81%8A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://blog.zhaoyh.com.cn/2023/02/20/%E8%81%8A%E4%B8%80%E8%81%8A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2023-02-20T13:09:21.000Z</published>
    <updated>2023-06-07T00:55:37.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-单元测试释疑"><a href="#1-单元测试释疑" class="headerlink" title="1. 单元测试释疑"></a>1. 单元测试释疑</h3><p>今天聊聊单元测试。</p><p>单元测试的概念，在维基百科中是这样描述的：</p><blockquote><p>在计算机编程中，单元测试又称为模块测试，是针对程序模块来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、抽象类、或者派生类中的方法。</p></blockquote><span id="more"></span><p>单元测试侧重的是最小的运行单元，对于大部分的开发同学来说，写完一个<code>Service</code>后，如果项目本身有单元测试覆盖率的要求，多多少少都会写过类似下面的单元测试代码（如果没有单测的要求，我也相信大部分同学是没有写单元测试习惯的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = SpringbootOrderApplication.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getOrder(orderId);</span><br><span class="line">        assertNotNull(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，依据单元测试的定义，这段代码，并不是只测试<code>getOrder</code>这个接口，<code>orderService</code>里也有可能会依赖DAO层的数据，也有可能会依赖下游的RPC接口，因此，这段测试，涉及到完整的查询订单的上下游逻辑，我们可以称之为”集成测试“。</p><p>那么问题来了，你说这是集成测试，那我这一段要怎么写单元测试呢？在下一章我们细细道来。</p><h3 id="2-集成测试和单元测试"><a href="#2-集成测试和单元测试" class="headerlink" title="2. 集成测试和单元测试"></a>2. 集成测试和单元测试</h3><p>我们首先总结下集成测试的特点：</p><ul><li>需要服务启动并初始化；</li><li>需要依赖上下游的数据；</li><li>可以使用Springboot的<code>Autowired</code>依赖注入；</li><li>上下游链路比较长，有时很难直接用Assert断言判断；</li></ul><p>单元测试有如下的特点：</p><ul><li>不需要启动应用和初始化；</li><li>不依赖上下游的数据；</li><li>使用<code>@Mock</code>注解修饰依赖的对象；</li><li>用<code>@InjectMocks</code>来初始化测试对象；</li><li>可以直接用Assert相关方法进行断言；</li></ul><p>基于<code>JUnit + Mockito</code>编写的单元测试用例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(MockitoJUnitRunner.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义依赖对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> IOrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义测试对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 注入依赖的方法</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">orderMock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(orderId, <span class="string">&quot;order-name&quot;</span>, <span class="number">2D</span>, <span class="number">1</span>);</span><br><span class="line">        Mockito.doReturn(orderMock).when(orderMapper).selectOrderById(orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证依赖的方法</span></span><br><span class="line">        Mockito.verify(orderMapper).selectOrderById(orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证service的查询结果</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">orderTest</span> <span class="operator">=</span> orderService.getOrder(orderId);</span><br><span class="line">        assertNotNull(orderTest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证依赖的对象</span></span><br><span class="line">        Mockito.verifyNoInteractions(orderMapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-什么是好的单侧"><a href="#3-什么是好的单侧" class="headerlink" title="3. 什么是好的单侧"></a>3. 什么是好的单侧</h3><blockquote><p>在业界，单元测试的标准有AIR原则和FIRST原则。单元测试在线上运行时，感觉像空气(AIR)一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p></blockquote><p>AIR原则的内容如下：</p><ul><li>A-Automatic：单元测试应该是全自动执行的，单元<br>测试中不准使用System.out来进行人肉验证，必须使用assert来验证；</li><li>I-Independent：保持单元测试的独立性，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序；</li><li>R-Repeatable：单元测试是可重复执行的，不应受外部的影响；</li></ul><p>FIRST原则的内容如下：</p><ul><li>F-Fast：单元测试应该是可以快速运行的，在各种测试方法中，单元测试的运行速度是最快的；</li><li>I-Independent：可以独立运行的，单元测试用例互相之间无依赖，且对外部资源也无任何依赖；</li><li>R-Repeatable：单元测试应该可以稳定重复的运行，并且每次运行的结果都是稳定可靠的；</li><li>S-SelfValidating：单元测试应该是用例自动进行验证的，不能依赖人工验证；</li><li>T-Timely：单元测试必须及时进行编写，更新和维护，以保证用例可以随着业务代码的变化动态的保障质量；</li></ul><h3 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h3><ul><li><a href="https://mp.weixin.qq.com/s/h8z29VoJeAmaMgq4EaCfQQ">那些年，我们写过的无效单元测试</a></li><li><a href="https://mp.weixin.qq.com/s/e1IxnViIT9LEVHW8aOH1dg">Java单元测试典型案例集锦</a></li></ul><blockquote><p>以上内容就是关于单元测试的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-单元测试释疑&quot;&gt;&lt;a href=&quot;#1-单元测试释疑&quot; class=&quot;headerlink&quot; title=&quot;1. 单元测试释疑&quot;&gt;&lt;/a&gt;1. 单元测试释疑&lt;/h3&gt;&lt;p&gt;今天聊聊单元测试。&lt;/p&gt;
&lt;p&gt;单元测试的概念，在维基百科中是这样描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机编程中，单元测试又称为模块测试，是针对程序模块来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、抽象类、或者派生类中的方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="其他" scheme="http://blog.zhaoyh.com.cn/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="单元测试" scheme="http://blog.zhaoyh.com.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务总结</title>
    <link href="http://blog.zhaoyh.com.cn/2022/11/16/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.zhaoyh.com.cn/2022/11/16/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-16T12:23:02.000Z</published>
    <updated>2023-06-07T00:55:37.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式事务产生的背景"><a href="#1-分布式事务产生的背景" class="headerlink" title="1. 分布式事务产生的背景"></a>1. 分布式事务产生的背景</h3><h4 id="1-1-数据库水平拆分"><a href="#1-1-数据库水平拆分" class="headerlink" title="1.1 数据库水平拆分"></a>1.1 数据库水平拆分</h4><p>对于大部分的业务而言，在起步阶段，为了快速上线，一般都是单库单表的。但是随着业务的扩张，数据量也随着扩增，单库的性能逐渐变差，就会有数据库的单点压力。因此我们就需要考虑数据库的分库分表方案了。分库分表的目的在于减少单库的负担，提高读写性能。策略可以归纳为拆表和拆分库，拆表是把表的字段进行拆分，即一张表拆分为多张表，这样就使得单表的行数降低，提升查询效率。但是单纯的库内分表只解决了单表的数据过大的问题，并不能解决在同一数据库服务器上的硬件瓶颈，因此需要同时考虑拆库，将原来的单库单表进行拆分数据片，如下图所示：</p><span id="more"></span><p><img src="https://static.zhaoyh.com.cn/1677074547110.jpg" alt="image"></p><p>分库分表之后，原来在一个数据库上就能完成的写操作，可能就会跨多个数据库，这就产生了跨数据库事务问题。</p><h4 id="1-2-SOA微服务化"><a href="#1-2-SOA微服务化" class="headerlink" title="1.2 SOA微服务化"></a>1.2 SOA微服务化</h4><p>随着业务以及技术的演进，单体架构的瓶颈也越来越明显。按照面向服务的架构（SOA）的原则，我们需要一个既能解决业务之间耦合性，又具备高可用、可伸缩的需求越来越强烈。在将单体架构，拆分为多个业务服务之后，每块业务只需要关注自己的服务即可，形成了一种高内聚、低耦合的架构设计方案，此时简易系统架构图如下：</p><p><img src="https://static.zhaoyh.com.cn/1677076101910.jpg" alt="image"></p><p>业务系统按照服务拆分之后，一个完整的业务往往需要调用多个服务，此时，不可避免地会产生数据不一致的问题。由于涉及到多个服务以及多个数据库，本地事务肯定无法满足需求，因此分布式事务就登上了舞台。简单一句话概括分布式事务：为了保证不同服务、不同数据库的数据一致性的事务解决方案。</p><h3 id="2-CAP原则"><a href="#2-CAP原则" class="headerlink" title="2. CAP原则"></a>2. CAP原则</h3><p>在计算机科学理论中，CAP定理指出，在一个分布式系统中，不可能同时满足以下三点，最多满足两个：</p><ul><li><strong>一致性（Consistence）</strong>，所有节点每次读写都能保证获取最新数据，即分布式系统内所有节点的数据副本保持强一致性；</li><li><strong>可用性（Availability）</strong>，每次请求数据都能得到响应，但不一定是最新的数据，无论任何故障产生后，需要保证服务仍然可用；</li><li><strong>分区容错性（Partition Tolerance）</strong>，被分区的节点可以正常对外提供服务；</li></ul><p><img src="https://static.zhaoyh.com.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzI0LzE2MzkxMmU5NzNlY2I5M2M.png" alt="image"></p><p>对于常规的分布式系统而言，分区容错性是一个最基本的要求，因此，在分布式事务解决方案时，只能选择PC或者AP的模式。</p><h3 id="3-基础协议"><a href="#3-基础协议" class="headerlink" title="3. 基础协议"></a>3. 基础协议</h3><h4 id="3-1-XA协议"><a href="#3-1-XA协议" class="headerlink" title="3.1 XA协议"></a>3.1 XA协议</h4><p>在讲分布式事务之前，必然需要先了解XA协议。XA是一个协议，是X&#x2F;Open组织制定的关于分布式事务的一组标准接口，实现这些接口，便意味支持XA协议。XA协议制定的主要标准有：</p><ul><li>定义了分布式事务参与方的两个角色，事务协调者和事务参与者；</li><li>定义了相关接口，只有定义无实现；</li></ul><p>其中二阶段提交（2PC）就是XA分布式事务标准的一种实现协议。</p><h4 id="3-2-两阶段提交协议"><a href="#3-2-两阶段提交协议" class="headerlink" title="3.2 两阶段提交协议"></a>3.2 两阶段提交协议</h4><p>两阶段提交协议包含的术语：</p><ul><li>TM（Transaction Manager），事务管理器，生成全局的事务id，并把多个本地事务协调为全局的分布式事务；</li><li>RM（Resource Manager），资源管理器，事务的参与者；</li></ul><p>二阶段提交的算法思路可以概括为如下图：</p><p><img src="https://static.zhaoyh.com.cn/1677587544238.jpg" alt="image"></p><p>两阶段提交协议将分布式事务的提交拆分为2个阶段：</p><p>第一阶段：准备阶段</p><p>TM给每个RM发送prepare消息，用于预留事务所需的资源，如果每个RM都资源预留成功，则进行第二阶段资源提交，否则协调RM回滚资源。</p><p>第二阶段：提交阶段</p><p>如果TM收到了RM的失败消息或者超时，直接给每个RM发送回滚(Rollback)消息；否则，发送提交(Commit)消息；RM根据TM的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><p>2PC可能存在的一些问题：</p><ul><li>执行过程中，所有参与节点都是事务阻塞型的，可能会存在数据库资源锁定时间过长以及TM等待时间过长的问题，这会导致系统整体的并发吞吐量变低；</li><li>单点故障问题，TM在两段提交中具有举足轻重的作用，一旦TM故障，整个系统将无法工作，因此需要投入巨大的精力来保障TM的高可用性；</li><li>必须假设网络在提交阶段的短时间内是可靠的，在阶段二中，如果TM向RM发送commit请求之后，发生了网络异常，会导致只有一部分RM接收到了commit请求，没有接收到commit请求的RM最终会执行回滚操作，从而造成数据不一致问题；</li></ul><h4 id="3-3-三阶段提交协议"><a href="#3-3-三阶段提交协议" class="headerlink" title="3.3 三阶段提交协议"></a>3.3 三阶段提交协议</h4><p>三阶段提交协议流程示意图如下：</p><p><img src="https://static.zhaoyh.com.cn/1677587641931.jpg" alt="image"></p><ul><li><strong>阶段一CanCommit</strong>，TM协调者向参与者发送can_commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应，这是比2PC多的一步骤，提前询问各个节点是否准备成功，防止超时；</li><li><strong>阶段二PreCommit</strong>，根据阶段一的反馈结果分为两种情况，情况1假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行；情况2假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断；</li><li><strong>阶段三DoCommit</strong>，该阶段进行真正的事务提交；</li></ul><p>可以看出，3PC可以解决单点故障问题，并减少阻塞问题，。三阶段提交协议引入了超时机制，一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit，而不会一直持有事务资源并处于阻塞状态。</p><p>但是3PC对于数据一致性问题并未有任何改进，比如在进入PreCommit阶段后，如果协调者发送的是abort指令，而此时由于网络问题，有部分参与者在等待超时后仍未收到Abort指令的话，那这些参与者就会执行commit，这样就产生了不同参与者之间数据不一致的问题。</p><p>由于3PC非常难实现，目前市面上主流的分布式事务解决方案基本都是2PC协议。</p><h3 id="4-最终一致性解决方案"><a href="#4-最终一致性解决方案" class="headerlink" title="4. 最终一致性解决方案"></a>4. 最终一致性解决方案</h3><h4 id="4-1-TCC模式"><a href="#4-1-TCC模式" class="headerlink" title="4.1 TCC模式"></a>4.1 TCC模式</h4><p>TCC是柔性事务的一种，即追求最终一致性，并不要求每一步的强一致性，TCC采用补偿机制达到最终一致性。针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。TCC是Try、Confirm、Cancel三个单词的缩写，其本质是一个应用（业务）层面上的2PC协议实现：</p><ul><li><strong>准备阶段</strong>，TM协调者调用每个节点提供的try接口，将整个全局事务涉及到的资源锁住，若锁定成功，try接口向TM返回yes状态；</li><li><strong>提交阶段</strong>，若所有RM节点的try接口在阶段一都返回yes，则进入提交阶段，TM调用所有服务的confirm接口，各个RM节点进行事务提交。如果有任何一个服务的try接口在阶段一返回no或者超时，则TM协调者调用所有服务的cancel接口。</li></ul><p>所以TCC的实际执行情况，要么是Try-&gt;Confirm，要么是Try-&gt;Cancel。</p><p><img src="https://static.zhaoyh.com.cn/tcc_show_1.png" alt="image"></p><p>TCC是如何解决二阶段单点故障问题的呢？答案是重试机制。由于try操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是confirm阶段失败还是cancel阶段失败都能通过不断重试直至confirm或cancel成功。</p><p>由于有TM的重试机制，RM节点confirm和cancel的接口实现必须是幂等的。</p><h4 id="4-2-Saga模式"><a href="#4-2-Saga模式" class="headerlink" title="4.2 Saga模式"></a>4.2 Saga模式</h4><p>Saga模式的思想，来源于这篇<a href="http://www.amundsen.com/downloads/sagas.pdf">论文</a>，作者提出了将一个长事务，分拆成多个子事务，每个子事务有正向操作Ti，反向补偿操作Ci。</p><p><img src="https://static.zhaoyh.com.cn/TB1Y2kuw7T2gK0jSZFkXXcIQFXa-445-444.png" alt="image"></p><ul><li>假如所有的子事务Ti依次成功完成，则全局事务完成；</li><li>假如子事务Ti失败，那么会调用Ci, Ci-1, Ci-2 ….进行补偿；</li></ul><p>Saga模式的使用场景：</p><ul><li>业务流程长、业务流程多（订票、订餐）；</li><li>其他具有长事务特点的业务；</li></ul><h4 id="4-4-基于消息队列的最终一致性解决方案"><a href="#4-4-基于消息队列的最终一致性解决方案" class="headerlink" title="4.4 基于消息队列的最终一致性解决方案"></a>4.4 基于消息队列的最终一致性解决方案</h4><p>无论是2PC、3PC还是TCC模式，基本都遵守XA协议的规范，即这些方案本质上都是事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的ACID特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。</p><p>但是这些全局事务方案由于操作繁琐、时间跨度大，或者在全局事务期间会排他地锁住相关资源，使得整个分布式系统的全局事务的并发度不会太高。这很难满足高并发场景对事务吞吐量的要求。</p><p>基于消息中间件的最终一致性全局事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用MQ实现微服务之间的异步调用、解耦合和流量削峰，支持全局事务的高并发，并保证分布式数据记录的最终一致性。</p><p>目前RocketMQ、Pulsar均支持了事务性消息。</p><h3 id="5-企业级分布式事务解决方案"><a href="#5-企业级分布式事务解决方案" class="headerlink" title="5. 企业级分布式事务解决方案"></a>5. 企业级分布式事务解决方案</h3><p>前面几节我们介绍了分布式事务的理论基础，本小节我们再来了解一下目前业界比较热门的分布式事务落地方案。</p><h4 id="5-1-Seata"><a href="#5-1-Seata" class="headerlink" title="5.1 Seata"></a>5.1 Seata</h4><p>Seata是一款阿里开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata将为用户提供了TCC、SAGA和XA事务模式，为用户打造一站式的分布式解决方案。关于Seata的详细介绍可参考文章：<a href="http://c19.f.dzxt.sbs/v8KdWkN">Spring Boot(七)之基于Dubbo和Seata的分布式事务解决方案</a></p><p>如下图所示，Seata中有三大模块，分别是TM、RM和TC。 其中TM和RM是作为Seata的客户端与业务系统集成在一起，TC作为Seata的服务端独立部署。</p><p><img src="https://static.zhaoyh.com.cn/1561960663764-249954ff-46ed-4d30-8041-2301a677bfb9.png" alt="image"></p><p>Seata支持4种分布式事务解决方案，分别是AT模式、TCC模式、Saga模式和XA模式。</p><p>在Seata中，分布式事务的执行流程：</p><ul><li>TM开启分布式事务（TM向TC注册全局事务记录）；</li><li>按业务场景，编排数据库、服务等事务内资源（RM 向TC汇报资源准备状态 ）；</li><li>TM结束分布式事务，一阶段结束（TM通知TC提交&#x2F;回滚分布式事务）；</li><li>TC汇总事务信息，决定分布式事务是提交还是回滚；</li><li>TC通知所有RM提交&#x2F;回滚资源，二阶段结束；</li></ul><h4 id="5-2-DTM"><a href="#5-2-DTM" class="headerlink" title="5.2 DTM"></a>5.2 DTM</h4><p><a href="https://github.com/dtm-labs/dtm">DTM</a>是一款golang开发的分布式事务管理器，目前star数4.6k，它解决了跨数据库、跨服务、跨语言栈更新数据的一致性问题。他优雅的解决了幂等、空补偿、悬挂等分布式事务难题，提供了简单易用、高性能、易水平扩展的解决方案。</p><p>DTM的主要优点如下：</p><ul><li>易接入：零配置启动服务，提供非常简单的HTTP接口，极大降低上手分布式事务的难度，新手也能快速接入；</li><li>跨语言：可适合多语言栈的公司使用。方便go、python、php、nodejs、ruby、c# 各类语言使用；</li><li>使用简单：开发者不再担心悬挂、空补偿、幂等各类问题，首创子事务屏障技术代为处理；</li><li>易部署、易扩展：依赖mysql|redis，部署简单，易集群化，易水平扩展；</li><li>多种分布式事务协议支持：TCC、SAGA、XA、二阶段消息，一站式解决所有分布式事务问题；</li></ul><p><img src="https://static.zhaoyh.com.cn/dtsAndSeata.jpeg" alt="image"></p><h3 id="6-参考文档"><a href="#6-参考文档" class="headerlink" title="6. 参考文档"></a>6. 参考文档</h3><ul><li><a href="https://www.sofastack.tech/blog/sofa-meetup-3-seata-retrospect/">分布式事务Seata Saga模式首秀以及三种模式详解</a></li><li><a href="https://mp.weixin.qq.com/s/68mPpjMjPbbaaxBKacEHAw">分布式事务中间件Seata的设计原理</a></li></ul><blockquote><p>以上内容就是分布式事务总结的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author：zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-分布式事务产生的背景&quot;&gt;&lt;a href=&quot;#1-分布式事务产生的背景&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式事务产生的背景&quot;&gt;&lt;/a&gt;1. 分布式事务产生的背景&lt;/h3&gt;&lt;h4 id=&quot;1-1-数据库水平拆分&quot;&gt;&lt;a href=&quot;#1-1-数据库水平拆分&quot; class=&quot;headerlink&quot; title=&quot;1.1 数据库水平拆分&quot;&gt;&lt;/a&gt;1.1 数据库水平拆分&lt;/h4&gt;&lt;p&gt;对于大部分的业务而言，在起步阶段，为了快速上线，一般都是单库单表的。但是随着业务的扩张，数据量也随着扩增，单库的性能逐渐变差，就会有数据库的单点压力。因此我们就需要考虑数据库的分库分表方案了。分库分表的目的在于减少单库的负担，提高读写性能。策略可以归纳为拆表和拆分库，拆表是把表的字段进行拆分，即一张表拆分为多张表，这样就使得单表的行数降低，提升查询效率。但是单纯的库内分表只解决了单表的数据过大的问题，并不能解决在同一数据库服务器上的硬件瓶颈，因此需要同时考虑拆库，将原来的单库单表进行拆分数据片，如下图所示：&lt;/p&gt;</summary>
    
    
    
    <category term="基础服务" scheme="http://blog.zhaoyh.com.cn/categories/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="分布式事务" scheme="http://blog.zhaoyh.com.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>RedisLockRegistry分布式锁应用及分析</title>
    <link href="http://blog.zhaoyh.com.cn/2021/03/09/RedisLockRegistry%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/"/>
    <id>http://blog.zhaoyh.com.cn/2021/03/09/RedisLockRegistry%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%94%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/</id>
    <published>2021-03-09T04:04:01.000Z</published>
    <updated>2023-06-07T00:55:37.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-关于分布式锁"><a href="#1-关于分布式锁" class="headerlink" title="1. 关于分布式锁"></a>1. 关于分布式锁</h3><p>分布式锁就是应用在分布式环境下多个节点之间进行同步或者协作的锁，分布式锁和普通锁一样，也需要有以下特性：</p><ul><li>互斥性，保证只有持有锁的某个线程才能进行操作，即在任意时刻，只有一个节点的客户端能持有分布式锁；</li><li>可重入性，在同一个节点进程内，同一个线程可多次获取锁；</li><li>超时处理机制，需要支持超时自动释放锁，避免死锁的产生，以及避免其他节点长期等待造成的资源浪费；</li><li>锁释放机制，加锁和解锁必须是节点内的同一个线程；</li></ul><span id="more"></span><h3 id="2-RedisLockRegistry上手"><a href="#2-RedisLockRegistry上手" class="headerlink" title="2. RedisLockRegistry上手"></a>2. RedisLockRegistry上手</h3><p><code>RedisLockRegistry</code>是Spring-Integration集成工具包项目提供的基于Redis的分布式锁管理器，使用时，首先导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-integration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.integration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-integration-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次配置分布式锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置分布式锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> redisConnectionFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RedisLockRegistry <span class="title function_">redisLockRegistry</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">defaultExpireTime</span> <span class="operator">=</span> <span class="number">10000L</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisLockRegistry</span>(redisConnectionFactory, <span class="string">&quot;redis-lock&quot;</span>, defaultExpireTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RedisLockRegistry</code>相当于一个锁的管理器，所有的分布式锁都可以从中获取，如上定义，锁的键名为“redis-lock:你定义的key”，超时时间也可以自己设定，默认超时时间是60s。</p><p>使用分布式加锁时，只需要参考如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> redisLockRegistry.obtain(lockKey);</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 此处是你的代码逻辑，处理需要加锁的一些事务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 配合解锁逻辑</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RedisLockRegistry</code>是基于Redis的setnx和<code>ReentrantLock</code>可重入锁实现。下一章节，我们可以对其源码展开阅读及分析。</p><h3 id="3-RedisLockRegistry源码分析"><a href="#3-RedisLockRegistry源码分析" class="headerlink" title="3. RedisLockRegistry源码分析"></a>3. RedisLockRegistry源码分析</h3><h4 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a lock registry with the default (60 second) lock expiration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connectionFactory The connection factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registryKey The key prefix for locks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedisLockRegistry</span><span class="params">(RedisConnectionFactory connectionFactory, String registryKey)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(connectionFactory, registryKey, DEFAULT_EXPIRE_AFTER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a lock registry with the supplied lock expiration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connectionFactory The connection factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registryKey The key prefix for locks.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expireAfter The expiration in milliseconds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedisLockRegistry</span><span class="params">(RedisConnectionFactory connectionFactory, String registryKey, <span class="type">long</span> expireAfter)</span> &#123;</span><br><span class="line">Assert.notNull(connectionFactory, <span class="string">&quot;&#x27;connectionFactory&#x27; cannot be null&quot;</span>);</span><br><span class="line">Assert.notNull(registryKey, <span class="string">&quot;&#x27;registryKey&#x27; cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.redisTemplate = <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(connectionFactory);</span><br><span class="line"><span class="built_in">this</span>.obtainLockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(OBTAIN_LOCK_SCRIPT, Boolean.class);</span><br><span class="line"><span class="built_in">this</span>.registryKey = registryKey;</span><br><span class="line"><span class="built_in">this</span>.expireAfter = expireAfter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>OBTAIN_LOCK_SCRIPT</code>是一个上锁的lua脚本，因为若你在应用层面是分步骤的get&#x2F;set&#x2F;expire操作，是不符合原子性的，如果SETNX成功，在服务器挂掉、重启或网络问题等，导致EXPIRE命令没有执行，锁没有设置超时时间，后续就有可能变成死锁，所以最好的方式是通过lua脚本来实现加锁的操作。其lua加锁脚本为：</p><p><img src="https://static.zhaoyh.com.cn/1615217272515.jpg" alt="image"></p><p>其中KEYS[1]代表当前锁的key值，ARGV[1]代表当前的客户端标识，ARGV[2]代表过期时间。首先根据KEYS[1]从redis中拿到对应的客户端标识，如果已存在的客户端标识和ARGV[1]相等，那么重置过期时间为ARGV[2]；如果值不存在，设置KEYS[1]对应的值为ARGV[1]，并且过期时间设置ARGV[2]，从逻辑上来说，这就是一个简单的get和setnx操作。</p><h4 id="3-2-获取锁"><a href="#3-2-获取锁" class="headerlink" title="3.2 获取锁"></a>3.2 获取锁</h4><p>获取锁的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, RedisLock&gt; locks = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Lock <span class="title function_">obtain</span><span class="params">(Object lockKey)</span> &#123;</span><br><span class="line">Assert.isInstanceOf(String.class, lockKey);</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> (String) lockKey;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.locks.computeIfAbsent(path, RedisLock::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RedisLockRegistry</code>维护了一个key-RedisLock类型的<code>ConcurrentHashMap</code>，即在<code>RedisLockRegistry</code>中，每个key对应一个<code>RedisLock</code>。</p><h4 id="3-3-RedisLock"><a href="#3-3-RedisLock" class="headerlink" title="3.3 RedisLock"></a>3.3 RedisLock</h4><p><code>RedisLock</code>是<code>RedisLockRegistry</code>的内部实现类，实现了<code>Lock</code>接口，是锁的定义和实现逻辑落地的类。首先看加锁过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">localLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取可重入锁localLock</span></span><br><span class="line"><span class="built_in">this</span>.localLock.lock();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line"><span class="keyword">while</span> (!obtainLock()) &#123;</span><br><span class="line">    <span class="comment">// 每隔100ms便会重新发起请求分布式锁</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This method must be uninterruptible so catch and ignore</span></span><br><span class="line"><span class="comment"> * interrupts and only break out of the while loop when</span></span><br><span class="line"><span class="comment"> * we get the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="built_in">this</span>.localLock.unlock();</span><br><span class="line">rethrowAsLockException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看到，lock方法首先尝试获取<code>ReentrantLock</code>，如果获取，再尝试去获取分布式锁，使用localLock的目的在于减少节点本地多线程竞争分布式锁，使得每刻只有一个线程去竞争分布式锁，以减少不必要的资源开销，减轻Redis的压力。</p><p>本地线程如果获取不到分布式锁，则进行阻塞，直至获取到锁或者出现异常，所以每隔100毫秒会去尝试获取分布式锁，直到获取成功或者抛出异常为止。我们再来看下obtainLock方法的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> expireAfter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">obtainLock</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行加锁的lua脚本</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span></span><br><span class="line">RedisLockRegistry.<span class="built_in">this</span>.redisTemplate.execute(RedisLockRegistry.<span class="built_in">this</span>.obtainLockScript,</span><br><span class="line">Collections.singletonList(<span class="built_in">this</span>.lockKey), RedisLockRegistry.<span class="built_in">this</span>.clientId,</span><br><span class="line">String.valueOf(RedisLockRegistry.<span class="built_in">this</span>.expireAfter));</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Boolean.TRUE.equals(success);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 记录加锁时间</span></span><br><span class="line"><span class="built_in">this</span>.lockedAt = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取锁的过程比较简单，通过redisTemplate执行lua脚本获取Redis锁。</p><p><code>RedisLock</code>也定义了可中断锁的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="built_in">this</span>.localLock.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!obtainLock()) &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>); <span class="comment">//NOSONAR</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line"><span class="built_in">this</span>.localLock.unlock();</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line"><span class="keyword">throw</span> ie;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="built_in">this</span>.localLock.unlock();</span><br><span class="line">rethrowAsLockException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock方法不会响应中断信号，lockInterruptibly方法利用<code>ReentrantLock</code>的可中断机制，会响应中断信号，即假如获取锁的过程如果出现中断，则结束获取操作过程。</p><h4 id="3-4-解锁过程"><a href="#3-4-解锁过程" class="headerlink" title="3.4 解锁过程"></a>3.4 解锁过程</h4><p>解锁的方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁的入口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断localLock锁是否被当前线程持有</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.localLock.isHeldByCurrentThread()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;You do not own lock at &quot;</span> + <span class="built_in">this</span>.lockKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程持有的可重入锁的数量，即重入的次数</span></span><br><span class="line"><span class="comment">// 如果此时 &gt; 1，表示当前线程有多次获取可重入锁，释放的时候只减少本地锁的次数，不能释放分布式锁</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.localLock.getHoldCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.localLock.unlock();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断分布式锁的所有者是否是当前RedisLockRegistry实例</span></span><br><span class="line"><span class="keyword">if</span> (!isAcquiredInThisProcess()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Lock was released in the store due to expiration. &quot;</span> +</span><br><span class="line"><span class="string">&quot;The integrity of data protected by this lock may have been compromised.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 响应中断机制</span></span><br><span class="line"><span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">RedisLockRegistry.<span class="built_in">this</span>.executor.execute(<span class="built_in">this</span>::removeLockKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接删除key，释放锁</span></span><br><span class="line">removeLockKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">LOGGER.debug(<span class="string">&quot;Released lock; &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">ReflectionUtils.rethrowRuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放本地可重入锁</span></span><br><span class="line"><span class="built_in">this</span>.localLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断分布式锁的所有者是否是当前RedisLockRegistry实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAcquiredInThisProcess</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> RedisLockRegistry.<span class="built_in">this</span>.clientId.equals(</span><br><span class="line">RedisLockRegistry.<span class="built_in">this</span>.redisTemplate.boundValueOps(<span class="built_in">this</span>.lockKey).get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeLockKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查对应的Redis是否支持UNLINK命令</span></span><br><span class="line">    <span class="comment">// 该命令用于异步删除某个键，功能等同于del命</span></span><br><span class="line">    <span class="comment">// 非阻塞，只有在Redis4及以上版本才支持</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.unlinkAvailable) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RedisLockRegistry.<span class="built_in">this</span>.redisTemplate.unlink(<span class="built_in">this</span>.lockKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">LOGGER.warn(<span class="string">&quot;The UNLINK command has failed (not supported on the Redis server?); &quot;</span> +</span><br><span class="line"><span class="string">&quot;falling back to the regular DELETE command&quot;</span>, ex);</span><br><span class="line"><span class="built_in">this</span>.unlinkAvailable = <span class="literal">false</span>;</span><br><span class="line">RedisLockRegistry.<span class="built_in">this</span>.redisTemplate.delete(<span class="built_in">this</span>.lockKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">RedisLockRegistry.<span class="built_in">this</span>.redisTemplate.delete(<span class="built_in">this</span>.lockKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用总结"><a href="#4-使用总结" class="headerlink" title="4. 使用总结"></a>4. 使用总结</h3><p>本文主要介绍了基于<RedisLockRegistry>的分布式锁实现过程及简单源码阅读，其实基于Redis的分布式锁实现，主要是依托get和setnx的方法，再包裹一层本地的可重入锁即可。若有问题，也欢迎各位积极交流。</p><h3 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h3><ul><li><a href="https://docs.spring.io/spring-integration/docs/current/api/org/springframework/integration/redis/util/RedisLockRegistry.html">Class RedisLockRegistry</a></li></ul><blockquote><p>以上内容就是关于RedisLockRegistry分布式锁应用及分析的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author：zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-关于分布式锁&quot;&gt;&lt;a href=&quot;#1-关于分布式锁&quot; class=&quot;headerlink&quot; title=&quot;1. 关于分布式锁&quot;&gt;&lt;/a&gt;1. 关于分布式锁&lt;/h3&gt;&lt;p&gt;分布式锁就是应用在分布式环境下多个节点之间进行同步或者协作的锁，分布式锁和普通锁一样，也需要有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥性，保证只有持有锁的某个线程才能进行操作，即在任意时刻，只有一个节点的客户端能持有分布式锁；&lt;/li&gt;
&lt;li&gt;可重入性，在同一个节点进程内，同一个线程可多次获取锁；&lt;/li&gt;
&lt;li&gt;超时处理机制，需要支持超时自动释放锁，避免死锁的产生，以及避免其他节点长期等待造成的资源浪费；&lt;/li&gt;
&lt;li&gt;锁释放机制，加锁和解锁必须是节点内的同一个线程；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="基础服务" scheme="http://blog.zhaoyh.com.cn/categories/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Redis" scheme="http://blog.zhaoyh.com.cn/tags/Redis/"/>
    
    <category term="分布式锁" scheme="http://blog.zhaoyh.com.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库锁应用总结</title>
    <link href="http://blog.zhaoyh.com.cn/2021/02/23/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.zhaoyh.com.cn/2021/02/23/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-23T15:17:18.000Z</published>
    <updated>2023-06-07T00:55:37.948Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用MySQL数据库过程中，如果数据库的读写并发较高，会面对一系列的数据一致性的问题，此时需要对数据表或记录加锁操作来解决并发的一致性问题。</p><span id="more"></span><h3 id="1-锁类型"><a href="#1-锁类型" class="headerlink" title="1. 锁类型"></a>1. 锁类型</h3><p>我们从锁的类型和使用两个角度，对数据库锁做有以下几个方面的区分。</p><h4 id="1-1-从锁大类角度"><a href="#1-1-从锁大类角度" class="headerlink" title="1.1 从锁大类角度"></a>1.1 从锁大类角度</h4><ul><li><strong>乐观锁</strong>，乐观对待并发的数据修改，假设每次读写数据都不会有冲突，只在提交数据的时候检测有没有别的请求更新了这条记录。常见的乐观锁实现方式有数据版本（对数据加version）和对数据加时间戳等；乐观锁的实现层面更多是在业务层，适合并发量较小的场景；</li><li><strong>悲观锁</strong>，在读写数据时，认为会出现数据冲突，因此每个操作都会加锁来控制并发，悲观锁一般由MySQL实现，我们只需要在sql语句中体现即可；悲观锁的实现层面在数据库里，适合并发量较大的场景；</li></ul><h4 id="1-2-从锁的使用角度"><a href="#1-2-从锁的使用角度" class="headerlink" title="1.2 从锁的使用角度"></a>1.2 从锁的使用角度</h4><ul><li><strong>表锁</strong>，开销小、加锁快、无死锁、锁定力度大、并发支持度最低；</li><li><strong>行锁</strong>，开销大，加锁慢、会出现死锁、锁定粒度小、发生锁冲突的概率低、并发支持度高；行锁都是基于索引实现的，如果一条SQL语句用不到索引是不会使用行级锁的，会升级为表锁；</li><li><strong>页面锁</strong>，开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发支持度一般，此锁使用较少；</li></ul><h4 id="1-3-从悲观锁的角度"><a href="#1-3-从悲观锁的角度" class="headerlink" title="1.3 从悲观锁的角度"></a>1.3 从悲观锁的角度</h4><p>悲观锁是数据库层面实现的，它主要有两类：</p><ul><li><strong>共享锁</strong>，read lock，又称为读锁，为读取操作创建的锁，其他请求可以并发读取数据，但任何事务都不能在此时对数据进行修改，除非所有的共享锁均已释放；如果事务T对数据A加上共享锁后，其他事务只能对A再加共享锁，不能加排他锁，否则可能会出现死锁情况；获得共享锁的事务只能读数据，不能修改数据；在查询语句后面增加LOCK IN SHARE MODE，MySQL会对查询结果中的每行都加共享锁，当没有其他请求对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id = 1 lock in share mode;</span><br></pre></td></tr></table></figure><ul><li><strong>排它锁</strong>，writer lock，又称为写锁，若某个事务对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束或释放锁之前，其他事务不能对其进行加任何锁，即其他事务只能读；排它锁会阻塞所有的排它锁和共享锁；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id=1 for update;</span><br></pre></td></tr></table></figure><p>事务T对id为1的数据记录加了排他锁，此时其他事务就不能对id&#x3D;1的记录修改了。</p><h4 id="1-4-间隙锁"><a href="#1-4-间隙锁" class="headerlink" title="1.4 间隙锁"></a>1.4 间隙锁</h4><p>间隙锁严格来说属于行锁的一种，当我们使用<strong>范围查询</strong>数据而不是使用相等条件时，并请求共享锁或排他锁是，MySQL会给符合规范的在条件范围内的<strong>已有数据记录</strong>加锁，对于键值在条件范围内但并不存在的数据记录，叫做“间隙”（GAP），InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。假如一个表student，有150条记录，id是从1到150，则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id&gt;100 for update;</span><br></pre></td></tr></table></figure><p>这是一个带范围条件的检索，InnoDB不仅会对符合条件的student值为130的记录加锁，也会对student大于100（这些记录并不存在）的“间隙”加锁。InnoDB使用间隙锁的主要目的有：</p><ul><li>防止幻读，我们知道数据库默认的REPEATABLE_READ事务隔离级别是不能解决幻读问题的，对于上面的例子，要是不使用间隙锁，如果其他事务插入了id大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读，即发现多了一些原本不存在的记录；</li><li>符合MySQL的恢复机制；</li></ul><p>注意，在使用范围条件检索并锁定记录时，InnoDB间隙锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件，以免造成锁阻塞的情况，也会对执行性能造成影响。</p><h3 id="2-MyISAM引擎锁"><a href="#2-MyISAM引擎锁" class="headerlink" title="2. MyISAM引擎锁"></a>2. MyISAM引擎锁</h3><p>对使用MyISAM引擎的表进行读操作（加读锁），不会阻塞其他请求对同一表的读操作，但会阻塞对同一表的写操作。只有当读锁释放后，才能执行其他请求的写操作。</p><p>对使用MyISAM引擎的表进行写操作（加写锁），会阻塞其他请求对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</p><p>因此：</p><ul><li>读锁只会阻塞写操作，不会阻塞其他请求的读操作；</li><li>写锁会把读写操作都阻塞；</li></ul><h4 id="2-1-加锁和释放锁"><a href="#2-1-加锁和释放锁" class="headerlink" title="2.1 加锁和释放锁"></a>2.1 加锁和释放锁</h4><p>隐式上锁（自动上锁和释放锁）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select //上读锁</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert、update、delete //上写锁</span><br></pre></td></tr></table></figure><p>手动上锁和解锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock table student read; //上读锁</span><br><span class="line">select * from student; //可以正常读取，其他请求的读操作正常</span><br><span class="line">update student set name = 3 where id =2; //报错因被上读锁不能写操作</span><br><span class="line">unlock tables;// 解锁</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock table student write; //上写锁</span><br><span class="line">select * from student; //可以正常读取，其他请求的操作会被阻塞</span><br><span class="line">update student set name = 3 where id =2; //可以正常更新操作，其他请求的操作会被阻塞</span><br><span class="line">unlock tables;// 解锁</span><br></pre></td></tr></table></figure><h4 id="2-2-锁调度"><a href="#2-2-锁调度" class="headerlink" title="2.2 锁调度"></a>2.2 锁调度</h4><p>MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的，假如1个请求某个MyISAM表的读锁，同时另一个请求同一表的写锁，此时MySQL会让写操作先获得锁，因为 MySQL认为写请求一般比读请求要重要。这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。</p><h4 id="2-3-什么情况下使用表锁"><a href="#2-3-什么情况下使用表锁" class="headerlink" title="2.3 什么情况下使用表锁"></a>2.3 什么情况下使用表锁</h4><ul><li>全表更新，若事务需要更新表的大部分数据，此时行锁会导致执行效率降低，有可能会有更多的锁冲突；</li><li>多表查询，若事务涉及多个表，此时一次性锁定多个表，有利于事务的快速执行；</li></ul><h3 id="3-InnoDB引擎锁"><a href="#3-InnoDB引擎锁" class="headerlink" title="3. InnoDB引擎锁"></a>3. InnoDB引擎锁</h3><p> InnoDB引擎默认对行进行加锁和解锁，因此，更多的关注行记录的属性。锁的类型有：共享锁（S）、排他锁（X）、意向共享（IS）、意向排他（IX）。InnoDB存储引擎有3种行锁的算法，分别是：</p><ul><li>Record Lock，单行记录上的锁；</li><li>Gap Lock，间隙锁，锁定一个范围，但不包括记录本身；解决了事务并发的幻读问题；</li><li>Next-Key Lock，Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身；</li></ul><p>三种锁算法的关系可参考下图：<br><img src="https://static.zhaoyh.com.cn/1614073880452.jpg" alt="image"></p><h4 id="3-1-加锁和释放锁"><a href="#3-1-加锁和释放锁" class="headerlink" title="3.1 加锁和释放锁"></a>3.1 加锁和释放锁</h4><p>隐式上锁（自动上锁和释放锁）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select //不会上锁</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert、update、delete //上写锁</span><br></pre></td></tr></table></figure><p>显式上锁（手动）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tableName lock in share mode;//读锁</span><br><span class="line">select * from tableName for update;//写锁</span><br></pre></td></tr></table></figure><p>解锁（手动）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 提交事务（commit）</span><br><span class="line">2. 回滚事务（rollback）</span><br><span class="line">3. kill 阻塞进程</span><br></pre></td></tr></table></figure><h4 id="3-2-MVCC机制"><a href="#3-2-MVCC机制" class="headerlink" title="3.2 MVCC机制"></a>3.2 MVCC机制</h4><blockquote><p><strong>MVCC</strong> (MultiVersion Concurrency Control) 叫做多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。</p></blockquote><p>如果从数据库中读数据的同时，有另外写入数据的请求，那么读数据的人有可能会看到『半写』或者不一致的数据。最简单的方法通过加锁，让所有的读请求等待写请求提交完成，但是这样效率会很差。MVCC机制使用了一种不同的手段，每个连接到数据库的读请求，在某个瞬间看到的是数据库的一个快照，写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读请求来说是不可见的。</p><p>MVCC的机制就保证了，对于行记录上了写锁后，别的读请求可以使用快照继续读，而不被阻塞。</p><h4 id="3-3-InnoDB索引对锁的影响"><a href="#3-3-InnoDB索引对锁的影响" class="headerlink" title="3.3 InnoDB索引对锁的影响"></a>3.3 InnoDB索引对锁的影响</h4><ul><li>只有通过索引条件检索数据时，InnoDB才会使用行级锁，否则会使用表级锁，此时索引失效，行锁变表锁；</li><li>InnoDB通过索引来实现行锁，而不是通过锁住某条记录。因此，当操作的两条不同记录拥有相同的索引时，也会因为行锁被锁而发生等待；</li><li>如果数据表建有多个索引时，可以通过不同的索引锁定不同的行；</li></ul><h3 id="4-锁使用总结"><a href="#4-锁使用总结" class="headerlink" title="4. 锁使用总结"></a>4. 锁使用总结</h3><h4 id="4-1-常用命令"><a href="#4-1-常用命令" class="headerlink" title="4.1 常用命令"></a>4.1 常用命令</h4><p>查看表锁的加锁情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show open tables where in_use &gt; 0;</span><br></pre></td></tr></table></figure><p>查看表锁的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#x27;table_lock%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://static.zhaoyh.com.cn/1614090807257.jpg" alt="image"></p><ul><li>table_locks_immediate，产生表锁次数；</li><li>table_locks_waited，出现表级锁定争用而发生等待的次数，此值高说明存在着较严重的表锁竞争情况；</li></ul><p>查看行锁的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://static.zhaoyh.com.cn/1614090993182.jpg" alt="image"></p><ul><li>innodb_row_lock_current_waits，当前正在等待锁定的数量；</li><li>innodb_row_lock_time，从系统启动到现在锁定总时间长度；</li><li>innodb_row_lock_time_avg，每次等待所花平均时间；</li><li>innodb_row_lock_time_max，从系统启动到现在等待最长的一次所花时间；</li><li>innodb_row_lock_waits，系统启动后到现在总共等待的次数；</li></ul><h4 id="4-2-锁使用优化"><a href="#4-2-锁使用优化" class="headerlink" title="4.2 锁使用优化"></a>4.2 锁使用优化</h4><ul><li>数据的查询尽量通过索引，避免无索引时行锁升级为表锁；</li><li>合理规划数据检索的范围，避免间隙锁带来的性能损失；</li><li>合理使用事务，避免长事务过多占用锁；</li><li>设置合理的事务隔离级别，在支持并发和性能上取得平衡；</li></ul><h3 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h3><ul><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系</a></li><li><a href="https://juejin.cn/post/6844903668571963406">全面了解mysql锁机制</a></li><li><a href="https://learnku.com/articles/39212?order_by=vote_count">一张图彻底搞懂MySQL的锁机制</a></li><li><a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html">Innodb锁机制：Next-Key Lock 浅谈</a></li></ul><blockquote><p>以上内容就是MySQL数据库锁应用总结的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author：zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在使用MySQL数据库过程中，如果数据库的读写并发较高，会面对一系列的数据一致性的问题，此时需要对数据表或记录加锁操作来解决并发的一致性问题。&lt;/p&gt;</summary>
    
    
    
    <category term="基础服务" scheme="http://blog.zhaoyh.com.cn/categories/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="MySQL" scheme="http://blog.zhaoyh.com.cn/tags/MySQL/"/>
    
    <category term="数据库锁" scheme="http://blog.zhaoyh.com.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>深入理解G1垃圾收集器</title>
    <link href="http://blog.zhaoyh.com.cn/2021/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://blog.zhaoyh.com.cn/2021/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2021-01-29T14:56:41.000Z</published>
    <updated>2023-06-07T00:55:37.966Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-垃圾收集器简析"><a href="#1-垃圾收集器简析" class="headerlink" title="1. 垃圾收集器简析"></a>1. 垃圾收集器简析</h3><p>Java语言一直使用GC技术进行JVM自动内存管理，避免手动管理带来的一系列问题，以提升开发人员效率。衡量垃圾回收的三个最重要指标：</p><ul><li>内存占用（Footprint）；</li><li>吞吐量（Throughput）；</li><li>延迟（Latency）；</li></ul><span id="more"></span><p>目前的垃圾收集器能是尽量在这三个指标中寻找平衡，以达到最大的回收效率，能同时达到这三个指标完美的垃圾收集器是比较困难的，但是随着20多年来垃圾收集器的技术进步，一款优秀的收集器也越来越满足大家的需求。目前，比较经典的垃圾收集器有如下几种：</p><ul><li>Serial收集器，历史最悠久，GC是单线程，会有“Stop The World”，内存消耗最小，作用于新生代，基于标记-复制算法实现；</li><li>Serial Old收集器，是Serial的老年代版本，基于标记-整理算法实现，在JDK5及之前，和Parallel Scavenge搭配使用，以及作为CMS失败时的备选方案；</li><li>ParNew收集器，是Serial收集器的多线程并行版本，作用于新生代，基于标记-复制算法实现，也会暂停所有用户线程；</li><li>Parallel Scavenge收集器，作用于新生代，基于标记-复制算法实现，侧重于吞吐量，有自适应调节策略，合理搭配新生代和老年代大小；</li><li>Parallel Old收集器，是Parallel Scavenge的老年代版本，基于标记-整理算法实现，JDK6开始提供；</li><li>CMS收集器，作用于老年代，目标是低延迟，收集速度较快，基于标记-清除算法实现，会有内存碎片；</li></ul><p>各垃圾收集器作用域及组合关系可参考下图：</p><p><img src="https://static.zhaoyh.com.cn/3220737594-5e4cecff3aa23_articlex.png" alt="image"></p><h3 id="2-G1收集器"><a href="#2-G1收集器" class="headerlink" title="2. G1收集器"></a>2. G1收集器</h3><h4 id="2-1-G1收集器介绍"><a href="#2-1-G1收集器介绍" class="headerlink" title="2.1 G1收集器介绍"></a>2.1 G1收集器介绍</h4><p>Garbage First(G1)收集器是垃圾回收技术发展历史上里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的堆内存布局，自JDK7之后开始发布，到了JDK8 Update 40版本后，G1提供了类卸载的支持，这个版本的G1被Oracle称为全功能垃圾收集器（Fully-Featured Garbage Collector）。G1主要面向服务端应用，自JDK9之后，G1取代了Parallel Old + Parallel Old的组合，成为服务端模式下的默认垃圾收集器。也是自JDK9之后，CMS和Serial Old被标记为废弃（Deprecate）状态而不再推荐使用。</p><p>经典的GC收集器将对内存按代划分，这种划代方式的内存在逻辑上是连续的。而G1垃圾收集器将堆内存按Region划分，回收的衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器独有的Mixed GC模式。</p><h4 id="2-2-G1收集器堆内存分布"><a href="#2-2-G1收集器堆内存分布" class="headerlink" title="2.2 G1收集器堆内存分布"></a>2.2 G1收集器堆内存分布</h4><p>G1收集器的堆内存布局可参考下图：</p><p><img src="https://static.zhaoyh.com.cn/1611910925346.jpg" alt="image"></p><ul><li>E，新生代Eden空间；</li><li>S，新生代Survivor空间；</li><li>O，老年代空间；</li><li>H，Humongous区域，专门用来存储大对象；</li></ul><p>G1其实也遵循了按代回收的理念，只是不再固定的分配各代的大小，而是把连续的堆划分为多个大小相等的独立空间（Region），每一个Region，可以根据需要，扮演新生代（Eden、Survivor）、老年代的角色。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新对象还是老对象，熬过多次收集的旧对象都能够有较好的收集效果。G1中还有一类Humongous区域，G1认为大小大于等于Region一半的对象即可判定为大对象。对于超过1个Region容量的大对象，将会被存放在N个连续的H Region之中，G1的大多数行为都把H Region作为来年代的一部分来看待。</p><p>每个Region的大小可通过参数<code>-XX:G1HeapRegionSize</code>设定，取值范围1~32MB，且应该为2的N次幂。</p><h4 id="2-3-停顿预测模型"><a href="#2-3-停顿预测模型" class="headerlink" title="2.3 停顿预测模型"></a>2.3 停顿预测模型</h4><p>停顿预测模型（Pause Prediction Model）是指能够支持指定在一个长度为M的时间片段内，垃圾回收的时间不超过N的模型。G1的内存被划分为一系列不需要连续区域，即将Region作为单次回收的最小单元，每次垃圾回收到的空间都是Region大小的整数倍，这样可以有计划地避免在整个堆空间收集，也更容易控制垃圾回收时间。G1也会跟踪各个Region的价值大小，建立各个Region空间的优先级列表，已达到最大化的垃圾收集的收益。</p><p>那么如何建立可靠的停顿预测模型呢？用户在启动Java程序时可以通过<code>-XX:MaxGCPauseMillis</code>指定停顿时间的最大期望值，在垃圾收集过程中，G1收集每个Region的回收耗时，再根据历史数据的偏差、置信度等统计数据，由哪些Region组成的回收集合才能达到期望停顿值之内的最高收益。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  share/vm/gc_implementation/g1/g1CollectorPolicy.hpp</span><br><span class="line">double get_new_prediction(TruncatedSeq* seq) &#123;</span><br><span class="line">    return MAX2(seq-&gt;davg() + sigma() * seq-&gt;dsd(),</span><br><span class="line">                seq-&gt;davg() * confidence_factor(seq-&gt;num()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个预测计算公式中：davg表示衰减均值，sigma()返回一个系数，表示信赖度，dsd表示衰减标准偏差，confidence_factor表示可信度相关系数。而方法的参数TruncateSeq，是一个截断的序列，它只跟踪了序列中的最新的n个元素。TruncateSeq（继承了AbsSeq）中，用来计算衰减均值、衰减变量，衰减标准偏差等：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// src/share/vm/utilities/numberSeq.cpp</span><br><span class="line">void AbsSeq::add(double val) &#123;</span><br><span class="line">  if (_num == 0) &#123;</span><br><span class="line">    // if the sequence is empty, the davg is the same as the value</span><br><span class="line">    _davg = val;</span><br><span class="line">    // and the variance is 0</span><br><span class="line">    _dvariance = 0.0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // otherwise, calculate both</span><br><span class="line">    _davg = (1.0 - _alpha) * val + _alpha * _davg;</span><br><span class="line">    double diff = val - _davg;</span><br><span class="line">    _dvariance = (1.0 - _alpha) * diff * diff + _alpha * _dvariance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-G1收集器运行过程"><a href="#3-G1收集器运行过程" class="headerlink" title="3. G1收集器运行过程"></a>3. G1收集器运行过程</h3><h4 id="3-1-需要思考的问题"><a href="#3-1-需要思考的问题" class="headerlink" title="3.1 需要思考的问题"></a>3.1 需要思考的问题</h4><p>将Java堆按Region划分后，跨Region对象的引用怎么解决？G1的解决办法是每个Region维护自己的记忆集（Remembered Set），可以看做一个哈希表，key是别的Region的地址，value是本地的索引，通过这种双向的结构，记录下“我指向谁”和“谁指向我”的问题。由于需要额外记录这些数据，G1比其他经典收集器多了很多内存占用。</p><p>在并发标记阶段如何保证收集线程和用户线程互不干扰的运行？如果GC线程标记对象时，用户线程改变了对象之间的引用关系，必须保证不能打破原有的对象依赖图结构，G1采用原始快照（SATB，Snapshot At The Begining）算法来实现，由字面理解，SATB是GC开始时活着的对象的一个快照。根据对象标记算法，把遍历对象图结构中遇到的对象，按照“是否被访问过”分为三种颜色：</p><ul><li>白色，该对象未被垃圾收集器访问过，在可达性分析阶段结束后，若仍是白色，即代表对象不可达，会被当做垃圾收集掉；</li><li>黑色，对象已经被垃圾收集器访问过，且对象的所有引用也被扫描过了，它是安全存活的，因此黑色对象不可能指向白色对象；</li><li>灰色，表示对象已被垃圾收集器访问过，但这个对象还至少有一个引用还没有扫描过；</li></ul><p>此时，若用户线程和GC线程并发工作，用户也要修改对象间的引用关系结构，这样就会产生两种后果：一种是把原本消亡的对象标记为存活；另一种是会把原本存活的对象标记为消亡。</p><p>SATB快照的存在，就可以让G1采用如下办法解决上述问题：当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再以记录过的引用关系中的灰色对象为根，重新扫描一次，这样无论引用关系删除与否，都会按照最初的对象结构图进行搜索。虚拟机通过写屏障，实现操作记录的记录和修改，避免并发带来的问题。</p><p>G1垃圾收集器在收集过程中，此时若用户线程还在创建新对象，G1在每个Region中划出一部分空间用于垃圾收集过程中的新对象分配，而且在收集过程中，默认这块区域的对象都是存活的。</p><p>如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程的执行，导致Full GC而产生较长时间的”Stop The World”。</p><h4 id="3-2-垃圾回收过程"><a href="#3-2-垃圾回收过程" class="headerlink" title="3.2 垃圾回收过程"></a>3.2 垃圾回收过程</h4><ul><li>初始标记（Initial Marking），仅标记GC Roots能直接关联到的对象，这个阶段需要停顿线程，但耗时很短，借用进行Young GC的时候同步完成的，G1收集器在这个阶段没有额外的停顿；</li><li>并发标记（Concurrent Marking），从GC Root开始做可达性分析，扫描整个对象引用结构图，耗时较长，但是可与用户线程并发执行，扫描完成后，还要重新处理SATB记录下的并发时有引用修改的对象；</li><li>最终标记（Final Marking），此时用户线程也需要短暂暂停，用于处理并发标记结束后仍遗留的SATB记录；</li><li>筛选回收（Counting and Evacuation），更新Region数据，对Region的回收价值做优先级排序，根据用户期望时间值制定回收集合，然后把被回收的Region的存活对象复制到另一个空的Region区域，此阶段暂停所有用户线程；</li></ul><p>从上收集过程可以看出，用户指定期望停顿时间是G1收集器很重要的参数，它会让G1收集器在吞吐量和延迟两个指标之间取一个平衡。因此设置合理的期望停顿时间是必要的，通常设置为100到200ms是比较合理的。</p><h3 id="4-应用及总结"><a href="#4-应用及总结" class="headerlink" title="4. 应用及总结"></a>4. 应用及总结</h3><h4 id="4-1-G1使用"><a href="#4-1-G1使用" class="headerlink" title="4.1 G1使用"></a>4.1 G1使用</h4><p>如果你的JDK是9及之后的版本，那会默认开启G1收集器，G1收集器其他相关的参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-XX:+UseG1GC</code></td><td>使用G1收集器</td></tr><tr><td><code>-XX:MaxGCPauseMillis</code></td><td>设置G1期望停顿时间，默认值200ms</td></tr><tr><td><code>-XX:G1HeapRegionSize</code></td><td>设置Region大小</td></tr><tr><td><code>-XX:ParallelGCThreads</code></td><td>STW时间并行的线程数</td></tr><tr><td><code>-XX:ConcGCThreads</code></td><td>并发标记阶段的线程数</td></tr><tr><td><code>-XX:G1NewSizePercent</code></td><td>新生代占比最小值，默认值5%</td></tr><tr><td><code>-XX:G1MaxNewSizePercent</code></td><td>新生代占比最大值，默认值60%</td></tr></tbody></table><h4 id="4-2-G1总结"><a href="#4-2-G1总结" class="headerlink" title="4.2 G1总结"></a>4.2 G1总结</h4><p>G1垃圾收集器，从整体上来说，以Region划分，可以看做是基于标记-整理实现，但从局部来说，两个Region之间又是采用标记-复制的算法，因此G1垃圾收集器不会产生内存碎片，收集完成后能提供较完整的可用内存。</p><p>G1收集器的内存停顿模型，把内存的期望停顿时间交给了程序员，对控制GC停顿时间可依据不同的业务模型、硬件<br>条件来合理的设置。</p><p>G1收集器的额外负载高，G1的记忆集可能会占到整个堆容量的20%甚至更多。另外G1对写屏障的复杂操作要比其他收集器消耗更多的运算资源。</p><h3 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h3><ul><li><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">Getting Started with the G1 Garbage Collector</a> </li><li><a href="https://www.oracle.com/java/technologies/javase/hotspot-garbage-collection.html">Garbage First Garbage Collector</a></li><li><a href="https://tech.meituan.com/2016/09/23/g1.html">Java Hotspot G1 GC的一些关键技术</a></li><li><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java中9种常见的CMS GC问题分析与解决</a></li><li><a href="https://backstage.forgerock.com/knowledge/kb/article/a75965340">Best practice for JVM Tuning with G1 GC</a></li><li><a href="https://www.overops.com/blog/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/">Garbage Collectors – Serial vs. Parallel vs. CMS vs. G1</a></li></ul><blockquote><p>以上内容就是关于深入理解G1垃圾收集器的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-垃圾收集器简析&quot;&gt;&lt;a href=&quot;#1-垃圾收集器简析&quot; class=&quot;headerlink&quot; title=&quot;1. 垃圾收集器简析&quot;&gt;&lt;/a&gt;1. 垃圾收集器简析&lt;/h3&gt;&lt;p&gt;Java语言一直使用GC技术进行JVM自动内存管理，避免手动管理带来的一系列问题，以提升开发人员效率。衡量垃圾回收的三个最重要指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存占用（Footprint）；&lt;/li&gt;
&lt;li&gt;吞吐量（Throughput）；&lt;/li&gt;
&lt;li&gt;延迟（Latency）；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JVM系列" scheme="http://blog.zhaoyh.com.cn/categories/JVM%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="垃圾回收" scheme="http://blog.zhaoyh.com.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="GC" scheme="http://blog.zhaoyh.com.cn/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(十)之内嵌容器分析</title>
    <link href="http://blog.zhaoyh.com.cn/2020/12/10/Spring%20Boot(%E5%8D%81)%E4%B9%8B%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8%E5%88%86%E6%9E%90/"/>
    <id>http://blog.zhaoyh.com.cn/2020/12/10/Spring%20Boot(%E5%8D%81)%E4%B9%8B%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-12-10T09:01:05.000Z</published>
    <updated>2023-06-07T00:55:37.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-应用容器介绍"><a href="#1-应用容器介绍" class="headerlink" title="1. 应用容器介绍"></a>1. 应用容器介绍</h3><p>在Spring Boot框架中，默认的内嵌Web应用容器是<a href="http://tomcat.apache.org/">Tomcat</a>，Tomcat诞生较早，是目前应用比较广泛的Web容器，Tomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page的支持。</p><span id="more"></span><p><a href="https://undertow.io/">Undertow</a>是红帽软件旗下JBoss Community开发的轻量级高性能Servlet容器，Undertow 提供阻塞或基于XNIO的非阻塞机制。Undertow提供一个基础的架构用来构建Web服务器，完全兼容Java EE Servlet 3.1和低级非堵塞的处理器，在高并发情况下表现非常出色。</p><p><a href="https://www.eclipse.org/jetty/">Jetty</a>是Eclipse基金会旗下的开源Web容器，轻量级，易扩展，组件支持按需加载和可插拔，对最新Servlet规范支持响应快。</p><p>Spring Boot同时支持以上三种Servlet容器，用户可以按需选择。本文主要介绍了三种容器的切换，以及容器的核心配置，并对容器的选型做了一些对比实验。</p><h3 id="2-容器选择"><a href="#2-容器选择" class="headerlink" title="2. 容器选择"></a>2. 容器选择</h3><h4 id="2-1-容器切换"><a href="#2-1-容器切换" class="headerlink" title="2.1 容器切换"></a>2.1 容器切换</h4><p>Spring Boot默认的内嵌Web应用容器是Tomcat，因此你只需要引入<code>spring-boot-starter-web</code>依赖，默认的启动项就是Tomcat。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot常用Tomcat配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  tomcat:</span><br><span class="line">    #编码选择</span><br><span class="line">    uri-encoding: UTF-8</span><br><span class="line">    #最大连接数</span><br><span class="line">    max-connections: 10000</span><br><span class="line">    #最大等待队列长度</span><br><span class="line">    accept-count: 100</span><br><span class="line">    #链接建立超时时间</span><br><span class="line">    connection-timeout: 12000</span><br><span class="line">    threads:</span><br><span class="line">      #最大线程数</span><br><span class="line">      max: 200</span><br><span class="line">      #最小线程数</span><br><span class="line">      min-spare: 10</span><br></pre></td></tr></table></figure><ul><li>线程数是指，每一个HTTP请求到达Web服务器，Web服务器都会创建一个线程来处理该请求，该参数决定了同时可以处理多少个HTTP请求；</li><li>min-spare最小线程数是Tomcat启动时的初始化的线程数，max是维持的最大线程数，同时超过这个请求数后，客户端请求只能排队，等有线程释放才能处理；</li><li>当HTTP并发请求数达到最大线程数时，若有新的HTTP请求到来，这时Tomcat会将该请求放在等待队列中，这个accept-count就是指能够接受的最大等待数，如果等待队列也满了，这个时候再来新的请求就会被Tomcat拒绝（connection refused）；</li><li>最大连接数max-connections，Tomcat在任意时刻接收和处理的最大连接数；</li><li>最长等待时间，如果没有数据进来，等待一段时间后断开连接，释放线程，参数主要用于控制和客户端之间的连接的超时时间，有些恶意的客户端在建立完TCP连接之后不发送任何HTTP请求，服务器如果不对这种行为进行有效管控，则很快就会消耗完所有线程池资源，无法进行服务，该参数就是用来控制连接建立后在多长时间内服务器可以主动关闭连接的；</li></ul><p>若切换为Undertow容器，则只需要修改依赖，不需要修改其他配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot常用Undertow配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  undertow:</span><br><span class="line">    threads:</span><br><span class="line">      io: 200</span><br><span class="line">      worker: 400</span><br><span class="line">    direct-buffers: true</span><br><span class="line">    buffer-size: 64MB</span><br></pre></td></tr></table></figure><ul><li>threads.io，设置IO线程数，它主要执行非阻塞的任务，它们会负责多个连接，默认设置每个CPU核心一个线程，不要设置过大；</li><li>threads.worker，阻塞任务线程池，当执行servlet请求阻塞IO操作时，Undertow会从这个线程池中取得线程，默认值是io线程数*8；</li><li>direct-buffers，是否分配直接内存；</li><li>buffer-size，每块buffer的空间大小，空间越小利用越充分，不需要设置太大；</li></ul><p>若切换为Jetty容器，则只需要修改依赖，不需要修改其他配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot常用Jetty配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  jetty:</span><br><span class="line">    threads:</span><br><span class="line">      min: 10</span><br><span class="line">      max: 200</span><br><span class="line">      max-queue-capacity: 200</span><br><span class="line">      acceptors: 2</span><br><span class="line">      selectors: 4</span><br><span class="line">      idle-timeout: 60000ms</span><br></pre></td></tr></table></figure><ul><li>threads.min，最小处理线程数；</li><li>threads.max，最大处理线程数；</li><li>threads.max-queue-capacity，等待队列长度；</li><li>thread.acceptors，负责接受新连接，非阻塞；</li><li>threads.selectors，处理HTTP消息协议的解包，最后由工作线程处理请求，非阻塞；</li><li>threads.idle-timeout，空闲等待时间；</li></ul><h4 id="2-2-对比实验"><a href="#2-2-对比实验" class="headerlink" title="2.2 对比实验"></a>2.2 对比实验</h4><p>为了对比三个Servlet容器的性能，笔者做了简单测试，主要测试了容器的下行字符串的处理能力，其中本机测试环境参考如下：</p><table><thead><tr><th>环境</th><th>值</th></tr></thead><tbody><tr><td>软件环境</td><td>Mac OS Big Sur + Spring Boot 2.4.0 + jdk1.8</td></tr><tr><td>并发变量</td><td>并发数150，请求总数2000</td></tr></tbody></table><p>接口方法很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &#123;&quot;/&quot;, &quot;/index&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    json.put(<span class="string">&quot;date&quot;</span>, LocalDate.now());</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>吞吐量和请求耗时测试结果如下：</p><table><thead><tr><th>Web容器</th><th>吞吐量&#x2F;sec</th><th>单位耗时&#x2F;ms</th></tr></thead><tbody><tr><td>Undertow</td><td>3206</td><td>0.37</td></tr><tr><td>Tomcat</td><td>3022</td><td>0.35</td></tr><tr><td>Jetty</td><td>2997</td><td>0.34</td></tr></tbody></table><p><code>JConsole</code>监控的程序性能如下三图所示：</p><p><img src="https://static.zhaoyh.com.cn/1607581857406_undertow.jpg" alt="image"></p><center>图1. Undertow服务性能测试</center><p><img src="https://static.zhaoyh.com.cn/1607582064733_tomcat.jpg" alt="image"></p><center>图2. Tomcat服务性能测试</center><p><img src="https://static.zhaoyh.com.cn/1607581510331_jetty.jpg" alt="image"></p><center>图3. Jetty服务性能测试</center><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul><li>Undertow的吞吐量表现最好；</li><li>Tomcat和Undertow在CPU占用率上差距不大，但二者均明显优于Jetty；</li><li>三者的请求耗时差别不是很大；</li></ul><p>从结果来看，Tomcat和Undertow都是比较稳定的Servlet容器，并不像<a href="https://examples.javacodegeeks.com/enterprise-java/spring/tomcat-vs-jetty-vs-undertow-comparison-of-spring-boot-embedded-servlet-containers/">文档</a>中介绍的Undertow有明显的优势，综合来说，可以根据你的业务选型，或者项目组之前的技术栈选择自己合适的Servlet容器即可。</p><blockquote><p>以上内容就是关于Spring Boot(十)之内嵌容器分析的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-应用容器介绍&quot;&gt;&lt;a href=&quot;#1-应用容器介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 应用容器介绍&quot;&gt;&lt;/a&gt;1. 应用容器介绍&lt;/h3&gt;&lt;p&gt;在Spring Boot框架中，默认的内嵌Web应用容器是&lt;a href=&quot;http://tomcat.apache.org/&quot;&gt;Tomcat&lt;/a&gt;，Tomcat诞生较早，是目前应用比较广泛的Web容器，Tomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page的支持。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Boot/"/>
    
    
    <category term="Tomcat" scheme="http://blog.zhaoyh.com.cn/tags/Tomcat/"/>
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/tags/Spring-Boot/"/>
    
    <category term="Undertow" scheme="http://blog.zhaoyh.com.cn/tags/Undertow/"/>
    
    <category term="Jetty" scheme="http://blog.zhaoyh.com.cn/tags/Jetty/"/>
    
  </entry>
  
  <entry>
    <title>深入理解数据库索引</title>
    <link href="http://blog.zhaoyh.com.cn/2020/11/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>http://blog.zhaoyh.com.cn/2020/11/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</id>
    <published>2020-11-02T10:23:25.000Z</published>
    <updated>2023-06-07T00:55:37.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为什么要使用索引"><a href="#1-为什么要使用索引" class="headerlink" title="1. 为什么要使用索引"></a>1. 为什么要使用索引</h3><p>数据库索引的目的在于提高检索效率，这就好像我们沿着一个树，从树根开始找，沿着主干、树干、到最后的末梢，走了其中的一条路径。这比查询一个链表的结构效率要高得多。</p><span id="more"></span><h3 id="2-B树和B-树"><a href="#2-B树和B-树" class="headerlink" title="2. B树和B+树"></a>2. B树和B+树</h3><h4 id="2-1-B树"><a href="#2-1-B树" class="headerlink" title="2.1 B树"></a>2.1 B树</h4><p>B树，即多路平衡树，每一个节点存储数据项key&#x2F;data和指针，在同一个节点中数据是增序的，每个节点最多k个子节点，k的大小取决于磁盘页的大小，所有的叶子节点都在同一层。B树的结构可参考下图：</p><p><img src="https://static.zhaoyh.com.cn/1546632-20200830195348368-1304078258.png" alt="image"></p><p>可以看到每个磁盘块包含数据项和指针，如磁盘块1包含数据项17和35，包含P1、P2、P3等三个指针，P1指向小于17的磁盘块，P2指向17和35之间的磁盘块，P3指向大于35的磁盘块。B树大大降低了二叉树的高度，所以也就极大地提升了搜索性能。</p><h4 id="2-2-B-树"><a href="#2-2-B-树" class="headerlink" title="2.2 B+树"></a>2.2 B+树</h4><p>从B树图中可以看到每个节点中不仅包含数据项的key值，还有data值（表记录中除了主键的数据）。而存储空间是有限的，如果data值较大时将会导致每个磁盘块能存储的节点数量变小，这样会导致B树的高度变深，会增加查询时的磁盘I&#x2F;O次数，因此会影响查询性能。而B+树叶子节点只存储数据节点，叶子节点之间通过双向链表链接，非叶子节点只存储指针和键值key。由于非叶子节点不存储data，有更多的空间存放key，所以B+树的出度一般比B树要大，深度就更小，因此以B+树的磁盘检索效率比B树高，B+树的结构示意图如下：</p><p><img src="https://static.zhaoyh.com.cn/1546632-20200830201413134-394816073.png" alt="image"></p><p>如图所示，如果要查找数据项87，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定87在P2指针，在内存中的查找时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，87在79之后，锁定磁盘块3的P3指针，通过指针加载磁盘块9到内存，发生第三次IO，同时内存中做二分查找到87，结束查询，总计三次IO。真实的情况是，3层的B+树可以存储上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常高。</p><h4 id="2-3-为什么要使用B-树"><a href="#2-3-为什么要使用B-树" class="headerlink" title="2.3 为什么要使用B+树"></a>2.3 为什么要使用B+树</h4><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗，相对于内存存取，I&#x2F;O存取的时间成本要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中的磁盘I&#x2F;O操作次数。换句话说，索引的结构要尽量减少查找过程中磁盘的I&#x2F;O次数。在计算机体系结构中，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p><p>这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>：</p><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p></blockquote><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I&#x2F;O效率。</p><p><img src="https://static.zhaoyh.com.cn/1446087-0232b823e3f1eb3a.webp" alt="image"></p><p><strong>页</strong>是InnoDB引擎管理数据库的最小磁盘单位，页大小默认是16K。一次至少读取一页的数据到内存，或者刷新一页的数据到磁盘。假设表的主键类型为BIGINT占8个字节，指针类型也一般为8个字节，也就是说一个页中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值，三层B+树最多可以存储1K * 1K * 1K &#x3D; 10亿条记录。InnoDB存储引擎将根节点常驻内存，在查找数据时一次页的查找代表一次IO，所以对于10亿内量级的表，通过主键索引查询通常只需要1-3次IO操作即可查找到数据。</p><h3 id="3-MySQL索引实现"><a href="#3-MySQL索引实现" class="headerlink" title="3. MySQL索引实现"></a>3. MySQL索引实现</h3><h4 id="3-1-MyISAM引擎索引"><a href="#3-1-MyISAM引擎索引" class="headerlink" title="3.1 MyISAM引擎索引"></a>3.1 MyISAM引擎索引</h4><p>MyISAM使用B+树作为索引的数据结构，叶子结点的数据域存放的是行记录的地址。如下图所示：</p><p><img src="https://static.zhaoyh.com.cn/1608711444054.jpg" alt="image"></p><p>以Col1列作为主键索引的示意图，可以看到，叶子结点的data域存放的是数据记录的地址。如果我们在字段Col2上建一个索引（非主键索引），那么索引的结构如下：</p><p><img src="https://static.zhaoyh.com.cn/1608711570782.jpg" alt="image"></p><p>MyISAM首先按照B+树的搜索算法查询索引，如果指定的key存在，则取出data域的值，然后用data域的地址查询数据记录。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址（指针），因此MyISAM的索引方式也叫做非聚集的，之所以这么称呼是为了与InnoDB的聚集索引区分。<strong>这里的聚集是指索引和数据是否在一起</strong>。</p><h4 id="3-2-InnoDB引擎索引"><a href="#3-2-InnoDB引擎索引" class="headerlink" title="3.2 InnoDB引擎索引"></a>3.2 InnoDB引擎索引</h4><p>InnoDB的索引实现方式与MyISAM的区别有两个：</p><ul><li>InnoDB的数据文件本身就是索引文件。叶子结点保存了完整的数据记录，这种索引叫做<strong>聚集索引</strong>。聚集索引这种实现方式使得按主键搜索十分高效，直接能查出整行数据。由于InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形；</li><li>InnoDB引擎叶子节点的data域存储的是相应记录的值而不是地址；</li></ul><p><img src="https://static.zhaoyh.com.cn/1546632-20200919222451055-995072120.png" alt="image"></p><p>InnoDB的<strong>非主键索引</strong>（以其他列作为索引）data域存储相应记录主键的值。换句话说，InnoDB的所有非主键索引都引用主键的值作为data域。如下图所示：</p><p><img src="https://static.zhaoyh.com.cn/1608712160157.jpg" alt="image"></p><p>由上可知，使用非主键索引搜索时需要检索两遍索引，首先检索非主键索引获得主键(Primary Key)，然后用主键到主键索引树中检索获得完整记录，这个过程叫做<strong>回表查询</strong>。</p><p>为什么非主键索引结构叶子节点存储的是主键值，而不像主键索引那样直接存储完整的一行数据，这样就能避免二次检索？显然，这样做一方面节省了大量的存储空间，另一方面数据冗余较少，更新数据的效率较高，不用担心数据一致性的问题。</p><p>到了这里也很容易明白为什么不建议使用过长的字段作为主键，因为所有的非主键索引都引用主键值，过长的主键值会让非主键索引变得过大。</p><h3 id="4-索引建立原则"><a href="#4-索引建立原则" class="headerlink" title="4. 索引建立原则"></a>4. 索引建立原则</h3><ul><li>若使用InnoDB存储引擎，如果没有特殊需要，请永远使用一个与业务无关的自增字段作为主键，而且这个字段长度不宜过大。为什么？InnoDB使用聚集索引，数据记录本身存放在主索引（B+树）的叶子结点上，这就要求同一个叶子结点（大小为一个内存页或磁盘页）的数据记录按主键顺序存放，每当一条新的记录插入时，数据库会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页。如果使用自增主键，那么每次插入新的记录，记录就会顺序插入到当前节点的下一个位置。这样就会形成一个紧凑的索引结构，每次插入不需要移动已有数据，因此插入效率很高；</li><li>如果使用非自增主键（例如身份证号或学号这种无序字符串），每次插入主键近似随机，每次记录都要插入到现有索引页的中间的某个位置，这时不得不移动元素来完成插入，就增加了很多开销；</li><li>为经常需要排序、分组和联合操作的字段建立索引；</li><li>为常作为查询条件的字段建立索引；</li><li>限制索引的数目，索引不是越多越好，太多的索引会使插入和更新变慢；</li><li>尽量选择区分度高的列作为索引，区分度的公式是count(distinct column)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一索引的区分度是1；</li><li>删除不再使用或很少使用的索引；</li><li>尽量的扩展索引，而不是新建索引，能使用组合索引就不要新建索引；</li><li>索引列不能参与计算，比如from_unixtime(create_time) &#x3D; ’2019-05-21’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2019-05-21’)；</li></ul><h3 id="5-最左前缀匹配"><a href="#5-最左前缀匹配" class="headerlink" title="5. 最左前缀匹配"></a>5. 最左前缀匹配</h3><p>InnoDB以index(name,age,phone)三列建立联合索引的时候，是按照从左到右的顺序来建立搜索树的，即相当于创建了name单列索引，(name,age)联合索引，和(name,age,phone)联合索引。比如当用(张三,20,18811721028)这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,18811721028)这样的没有name列来搜索的时候，B+树就不知道下一步该搜索哪个节点了，必须要先根据name来搜索才能知道下一步去哪里查询。比如当用(张三,18811721028)这样的条件来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据。这就是MySQL建立联合索引时会遵守的<strong>最左前缀匹配原则</strong>。</p><p>保持最左前缀匹配原则，MySQL会一直向右匹配，直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的。</p><h3 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h3><ul><li><a href="https://www.jianshu.com/p/f3a1e17a4df6">MySQL主键索引(聚簇索引)与非主键索引(二级索引)</a></li><li><a href="https://www.cnblogs.com/itwild/p/13703259.html">一文读懂MySQL的索引结构及查询优化</a></li><li><a href="https://juejin.im/post/5b55b842f265da0f9e589e79">数据库神器之索引</a></li><li><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></li></ul><blockquote><p>以上内容就是深入理解数据库索引的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author：zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-为什么要使用索引&quot;&gt;&lt;a href=&quot;#1-为什么要使用索引&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要使用索引&quot;&gt;&lt;/a&gt;1. 为什么要使用索引&lt;/h3&gt;&lt;p&gt;数据库索引的目的在于提高检索效率，这就好像我们沿着一个树，从树根开始找，沿着主干、树干、到最后的末梢，走了其中的一条路径。这比查询一个链表的结构效率要高得多。&lt;/p&gt;</summary>
    
    
    
    <category term="基础服务" scheme="http://blog.zhaoyh.com.cn/categories/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="MySQL" scheme="http://blog.zhaoyh.com.cn/tags/MySQL/"/>
    
    <category term="索引" scheme="http://blog.zhaoyh.com.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(九)之声明式事务使用总结</title>
    <link href="http://blog.zhaoyh.com.cn/2020/09/27/Spring%20Boot(%E4%B9%9D)%E4%B9%8B%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.zhaoyh.com.cn/2020/09/27/Spring%20Boot(%E4%B9%9D)%E4%B9%8B%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-27T08:58:42.000Z</published>
    <updated>2023-06-07T00:55:37.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Spring事务机制"><a href="#1-Spring事务机制" class="headerlink" title="1. Spring事务机制"></a>1. Spring事务机制</h3><p>目前市面上所有的数据访问存储技术都支持事务处理机制，用于提供给API开启事务、提交事务、回滚操作等。Spring支持声明式事务，即使用注解来选择需要使用事务的方法，使用<code>@Transactional</code>注解在方法上表明该方法需要事务支持。在该方法被调用时，Spring会开启一个新事务。</p><span id="more"></span><p>Spring Boot使用事务支持非常方便，首先在配置类或者启动类中加上开启事务的注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableTransactionManagement</span><br></pre></td></tr></table></figure><p>其次，在你需要加事务的方法上，加注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public boolean someMethod() &#123;</span><br><span class="line">    // 处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上两步骤，你的这个<code>someMethod</code>方法就支持事务管理了。</p><h3 id="2-Transactional属性分析"><a href="#2-Transactional属性分析" class="headerlink" title="2. Transactional属性分析"></a>2. Transactional属性分析</h3><p><code>@Transactional</code>注解可以配置如下一些属性：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>propagation</td><td>事务传播行为</td></tr><tr><td>isolation</td><td>事务隔离级别</td></tr><tr><td>timeout</td><td>超时时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td>readOnly</td><td>读写属性配置，默认false，如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。</td></tr><tr><td>rollbackFor</td><td>回滚规则，定义异常回滚Class</td></tr><tr><td>rollbackForClassName</td><td>回滚规则，异常回滚名String</td></tr><tr><td>noRollbackFor</td><td>回滚规则，遇到不回滚Class</td></tr><tr><td>noRollbackForClassName</td><td>回滚规则，遇到不回滚String</td></tr></tbody></table><h4 id="2-1-事务传播行为"><a href="#2-1-事务传播行为" class="headerlink" title="2.1 事务传播行为"></a>2.1 事务传播行为</h4><p>事务传播行为是Spring独有的事务管理属性，不属于事务实际提供方数据库的行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。以以下代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    methodB();</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Transactional(propagation = XXX, isolation = XXX)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>代码中<code>methodA()</code>方法调用了<code>methodB()</code>方法，<code>methodB()</code>的事务传播行为由<code>@Transactional(propagation = XXX, isolation = XXX)</code>决定。这里需要注意的是<code>methodA()</code>并没有开启事务，某一个事务传播行为修饰的方法并不是必须要在开启事务的外围方法中调用。</p><p>在<code>org.springframework.transaction.annotation.Propagation.java</code>中，定义了7种事务的传播行为：</p><ul><li>REQUIRED，如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是Spring默认的选择。</li><li>SUPPORTS，如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>MANDATORY，如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW，创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>NOT_SUPPORTED，以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER，以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>NESTED，如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则执行与REQUIRED类似的操作。</li></ul><h4 id="2-2-事务隔离级别"><a href="#2-2-事务隔离级别" class="headerlink" title="2.2 事务隔离级别"></a>2.2 事务隔离级别</h4><p>隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p><p>在<code>org.springframework.transaction.annotation.Isolation.java</code>中定义了和MySQL保持一致的四个隔离级别：</p><ul><li>DEFAULT(使用数据库默认隔离级别)。</li><li>READ_UNCOMMITTED(未提交读)，事务可以读其他事务未提交的数据，优点是读写并行，性能高，缺点是容易产生脏读问题。</li><li>READ_COMMITTED(提交读)，一个事务只能读取另一个事务已经提交的数据，该级别会产生不可重读以及幻读问题，这跟READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新生成一个版本号，所以每次select的时候读的不是一个副本而是不同的副本。在每次select之间有其他事务更新了我们读取的数据并提交了，那就出现了不可重复读。</li></ul><p><img src="https://static.zhaoyh.com.cn/1601188806343.jpg" alt="image"></p><ul><li>REPEATABLE_READ(可重复读)，MySQL默认的隔离级别，一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同，这种级别下可以避免，脏读，不可重复读等查询问题。</li></ul><p><img src="https://static.zhaoyh.com.cn/repeatable_read_transaction.png" alt="image"></p><ul><li>SERIALIZABLE(事务依次执行)，不会产生数据读取不一致问题，但是性能最低；</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>READ_UNCOMMITTED</td><td>YES</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>READ_COMMITTED</td><td>NO</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>REPEATABLE_READ</td><td>NO</td><td>NO</td><td>YES</td><td>NO</td></tr><tr><td>SERIALIZABLE</td><td>NO</td><td>NO</td><td>NO</td><td>YES</td></tr></tbody></table><blockquote><p>以上内容就是关于Spring Boot(九)之声明式事务使用总结的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-Spring事务机制&quot;&gt;&lt;a href=&quot;#1-Spring事务机制&quot; class=&quot;headerlink&quot; title=&quot;1. Spring事务机制&quot;&gt;&lt;/a&gt;1. Spring事务机制&lt;/h3&gt;&lt;p&gt;目前市面上所有的数据访问存储技术都支持事务处理机制，用于提供给API开启事务、提交事务、回滚操作等。Spring支持声明式事务，即使用注解来选择需要使用事务的方法，使用&lt;code&gt;@Transactional&lt;/code&gt;注解在方法上表明该方法需要事务支持。在该方法被调用时，Spring会开启一个新事务。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/tags/Spring-Boot/"/>
    
    <category term="事务" scheme="http://blog.zhaoyh.com.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(八)之定时任务锁Shedlock</title>
    <link href="http://blog.zhaoyh.com.cn/2020/09/22/Spring%20Boot(%E5%85%AB)%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%94%81Shedlock/"/>
    <id>http://blog.zhaoyh.com.cn/2020/09/22/Spring%20Boot(%E5%85%AB)%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%94%81Shedlock/</id>
    <published>2020-09-22T08:21:57.000Z</published>
    <updated>2023-06-07T00:55:37.952Z</updated>
    
    <content type="html"><![CDATA[<p>在我们业务开发过程中，经常会有需求做一些定时任务，但是由于定时任务的特殊性，以及一些方法的幂等性要求，在分布式多节点部署的情况下，某个定时任务只需要执行一次。</p><span id="more"></span><h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h3><p><a href="https://github.com/lukas-krecan/ShedLock">ShedLock</a>是一个轻量级的分布式定时任务锁组件，使用其可以满足我们上面的技术需求，ShedLock官方简单自我介绍：</p><blockquote><p>ShedLock makes sure that your scheduled tasks are executed at most once at the same time. If a task is being executed on one node, it acquires a lock which prevents execution of the same task from another node (or thread). Please note, that if one task is already being executed on one node, execution on other nodes does not wait, it is simply skipped.</p></blockquote><p>Shedlock从严格意义上来说不是一个分布式任务调度框架，而是一个分布式锁。所谓的分布式锁，解决的核心问题就是各个节点中无法通信的痛点。各个节点并不知道这个定时任务有没有被其他节点的定时器执行，所以理论上只需要有一个各个节点都能够访问到的资源，用这个资源去标记这个定时任务有没有执行就可以了。</p><h3 id="2-Shedlock实现"><a href="#2-Shedlock实现" class="headerlink" title="2. Shedlock实现"></a>2. Shedlock实现</h3><p>Shedlock实现分布式锁，可以依赖如下组件：</p><ul><li>JdbcTemplate</li><li>Mongo</li><li>DynamoDB</li><li>DynamoDB 2</li><li>ZooKeeper (using Curator)</li><li>Redis (using Spring </li><li>RedisConnectionFactory)</li><li>Redis (using Jedis)</li><li>Hazelcast</li><li>Couchbase</li><li>ElasticSearch</li><li>CosmosDB</li><li>Cassandra</li><li>Multi-tenancy</li></ul><p>本文主要以来Redis为公共存储，实现定时任务的分布式锁。首先，我们假设你的Spring Boot项目已经引入了Redis，在项目的pom文件中加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javacrumbs.shedlock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shedlock-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javacrumbs.shedlock<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shedlock-provider-redis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>开启定时任务锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableSchedulerLock(defaultLockAtMostFor = &quot;PT30S&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShedlockConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LockProvider <span class="title function_">lockProvider</span><span class="params">(RedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisLockProvider</span>(redisTemplate.getConnectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>defaultLockAtMostFor &#x3D; “PT30S”表示默认锁的最大占用时间是30s；</li></ul><p>其次，在定时任务方法上，加上注解@SchedulerLock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过设置lockAtMostFor，我们可以确保即使节点死亡，锁也会被释放；</span></span><br><span class="line"><span class="comment"> * 通过设置lockAtLeastFor，我们可以确保它在30s内不会执行超过一次；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;00 12 15 22 * ?&quot;)</span></span><br><span class="line"><span class="meta">@SchedulerLock(name = &quot;testTask-1&quot;, lockAtMostFor = &quot;30s&quot;, lockAtLeastFor = &quot;10s&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTask1</span><span class="params">()</span> &#123;</span><br><span class="line">    LockAssert.assertLocked();</span><br><span class="line">    log.info(<span class="string">&quot;exec testTask1......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled(fixedRate = 10000L)</span></span><br><span class="line"><span class="meta">@SchedulerLock(name = &quot;testTask-2&quot;, lockAtMostFor = &quot;10s&quot;, lockAtLeastFor = &quot;2s&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTask2</span><span class="params">()</span> &#123;</span><br><span class="line">    LockAssert.assertLocked();</span><br><span class="line">    log.info(<span class="string">&quot;exec testTask2......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动多个节点，会发现，每次定时任务只有一个节点执行，定时任务执行后，在Redis里会看到两个key：job-lock:default:testTask-1和job-lock:default:testTask-2。</p><h3 id="3-Shedlock原理分析"><a href="#3-Shedlock原理分析" class="headerlink" title="3. Shedlock原理分析"></a>3. Shedlock原理分析</h3><p>Shedlock通过AOP，拿到TaskScheduler的行为做代理，并加入分布式锁实现所需要的功能。</p><p><img src="https://static.zhaoyh.com.cn/shedlock_aop.png" alt="image"></p><p>上锁入口在RedisLockProvider.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;SimpleLock&gt; <span class="title function_">lock</span><span class="params">(<span class="meta">@NonNull</span> LockConfiguration lockConfiguration)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="built_in">this</span>.buildKey(lockConfiguration.getName());</span><br><span class="line">    <span class="type">Expiration</span> <span class="variable">expiration</span> <span class="operator">=</span> getExpiration(lockConfiguration.getLockAtMostUntil());</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(tryToSetExpiration(<span class="built_in">this</span>.redisTemplate, key, expiration, SetOption.SET_IF_ABSENT)) ? Optional.of(<span class="keyword">new</span> <span class="title class_">RedisLockProvider</span>.RedisLock(key, <span class="built_in">this</span>.redisTemplate, lockConfiguration)) : Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title function_">tryToSetExpiration</span><span class="params">(StringRedisTemplate template, String key, Expiration expiration, SetOption option)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Boolean)template.execute((connection) -&gt; &#123;</span><br><span class="line">        <span class="type">byte</span>[] serializedKey = template.getKeySerializer().serialize(key);</span><br><span class="line">        <span class="type">byte</span>[] serializedValue = template.getValueSerializer().serialize(String.format(<span class="string">&quot;ADDED:%s@%s&quot;</span>, Utils.toIsoString(ClockProvider.now()), Utils.getHostname()));</span><br><span class="line">        <span class="keyword">return</span> connection.set(serializedKey, serializedValue, expiration, option);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出上锁，其实就是Redis的set操作的过程。</p><p>任务执行的入口，可以参考net.javacrumbs.shedlock.core.DefaultLockingTaskExecutor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; TaskResult&lt;T&gt; <span class="title function_">executeWithLock</span><span class="params">(<span class="meta">@NonNull</span> TaskWithResult&lt;T&gt; task, <span class="meta">@NonNull</span> LockConfiguration lockConfig)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    Optional&lt;SimpleLock&gt; lock = lockProvider.lock(lockConfig);</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockName</span> <span class="operator">=</span> lockConfig.getName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyLockedBy(lockName)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Already locked &#x27;&#123;&#125;&#x27;&quot;</span>, lockName);</span><br><span class="line">        <span class="keyword">return</span> TaskResult.result(task.call());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lock.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LockAssert.startLock(lockName);</span><br><span class="line">            logger.debug(<span class="string">&quot;Locked &#x27;&#123;&#125;&#x27;, lock will be held at most until &#123;&#125;&quot;</span>, lockName, lockConfig.getLockAtMostUntil());</span><br><span class="line">            <span class="keyword">return</span> TaskResult.result(task.call());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            LockAssert.endLock();</span><br><span class="line">            lock.get().unlock();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="type">Instant</span> <span class="variable">lockAtLeastUntil</span> <span class="operator">=</span> lockConfig.getLockAtLeastUntil();</span><br><span class="line">                <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> ClockProvider.now();</span><br><span class="line">                <span class="keyword">if</span> (lockAtLeastUntil.isAfter(now)) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Task finished, lock &#x27;&#123;&#125;&#x27; will be released at &#123;&#125;&quot;</span>, lockName, lockAtLeastUntil);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Task finished, lock &#x27;&#123;&#125;&#x27; released&quot;</span>, lockName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Not executing &#x27;&#123;&#125;&#x27;. It&#x27;s locked.&quot;</span>, lockName);</span><br><span class="line">        <span class="keyword">return</span> TaskResult.notExecuted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断lock是否可用，然后再执行任务task.call()。</p><blockquote><p>以上内容就是关于Spring Boot(八)之定时任务锁Shedlock的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我们业务开发过程中，经常会有需求做一些定时任务，但是由于定时任务的特殊性，以及一些方法的幂等性要求，在分布式多节点部署的情况下，某个定时任务只需要执行一次。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/tags/Spring-Boot/"/>
    
    <category term="Shedlock" scheme="http://blog.zhaoyh.com.cn/tags/Shedlock/"/>
    
  </entry>
  
  <entry>
    <title>Maven私服搭建与使用</title>
    <link href="http://blog.zhaoyh.com.cn/2020/07/16/Maven%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.zhaoyh.com.cn/2020/07/16/Maven%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-16T09:21:17.000Z</published>
    <updated>2023-06-07T00:55:37.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以Sonatype Nexus为例讲述Maven私服的搭建过程，以及发布jar包和使用私服jar包的过程。</p></blockquote><p>本篇文章主要的环境依赖如下：</p><table><thead><tr><th>软件</th><th>版本</th></tr></thead><tbody><tr><td>操作系统</td><td>CentOS</td></tr><tr><td>JDK</td><td>1.8+</td></tr></tbody></table><span id="more"></span><h3 id="1-Nexus搭建"><a href="#1-Nexus搭建" class="headerlink" title="1. Nexus搭建"></a>1. Nexus搭建</h3><p>在<a href="https://www.sonatype.com/nexus-repository-oss">Sonatype</a>下载免费的OSS版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#解压</span></span></span><br><span class="line">tar -zxvf nexus-3.25.0-03-unix.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#启动</span></span></span><br><span class="line">cd nexus-3.25.0-03/bin</span><br><span class="line">./nexus start</span><br></pre></td></tr></table></figure><p>注意：Nexus运行，官方推荐你的机器至少需要4G以上内存。</p><p>打开： http:&#x2F;&#x2F;你的IP:8081&#x2F; 按照提示输入admin账号密码即可，接下来创建你的自定义私有仓库：</p><p><img src="https://static.zhaoyh.com.cn/1594889329900.jpg" alt="image"><br>分别创建两个maven2(hosted)类型的私有仓库：zhaoyh-test-repo-snap(快照版)和zhaoyh-test-repo-release(正式版)，如图所示：</p><p><img src="https://static.zhaoyh.com.cn/1594889574672.jpg" alt="image"></p><p>今后，你就可以把jar包推送到这两个私有仓库即可，但是，这两个仓库对外是不能public访问的，因此，需要在maven-public仓库中引入这两个私有仓库：</p><p><img src="https://static.zhaoyh.com.cn/1594890199503.jpg" alt="image"></p><p>引入之后，你只需要在本地引入maven-public，就可以拿到私有仓库里的jar包了。</p><h3 id="2-发布jar包"><a href="#2-发布jar包" class="headerlink" title="2. 发布jar包"></a>2. 发布jar包</h3><p>在项目的pom.xml中，添加发布需要的仓库配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 发布到mvn仓库配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>zhaoyh-test-repo-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Release Repository of zhaoyh<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://你的IP:8081/repository/zhaoyh-test-repo-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>zhaoyh-test-repo-snap<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshot Repository of zhaoyh<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://你的IP:8081/repository/zhaoyh-test-repo-snap/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发布jar包到maven仓库需要账号密码，在你本地的maven的settings.xml文件中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>zhaoyh-test-repo-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>zhaoyh-test-repo-snap<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就可以执行命令发布jar包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean &amp;&amp; mvn deploy</span><br></pre></td></tr></table></figure><p>打开Nexus平台查看上传成功的jar包：</p><p><img src="https://static.zhaoyh.com.cn/1594890930193.jpg" alt="image"></p><h3 id="3-引用私服的jar包"><a href="#3-引用私服的jar包" class="headerlink" title="3. 引用私服的jar包"></a>3. 引用私服的jar包</h3><p>如果需要引用jar包的项目是基于maven构建，则在pom中加入仓库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 远程仓库配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>public Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://你的IP:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://你的IP:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要引用jar包的项目是基于gradle构建，则在build.gradle中加入仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line"></span><br><span class="line">    //maven私服</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &#x27;http://你的IP:8081/repository/maven-public/&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // maven中央仓库</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就一路顺风了，在pom.xml或build.gradle中引入你需要的包就可以。</p><blockquote><p>以上内容就是Maven私服搭建与使用的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author：zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文以Sonatype Nexus为例讲述Maven私服的搭建过程，以及发布jar包和使用私服jar包的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章主要的环境依赖如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;CentOS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;1.8+&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="基础服务" scheme="http://blog.zhaoyh.com.cn/categories/%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Maven私服" scheme="http://blog.zhaoyh.com.cn/tags/Maven%E7%A7%81%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>分布式调用链Sleuth服务应用及解析</title>
    <link href="http://blog.zhaoyh.com.cn/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E7%94%A8%E9%93%BESleuth%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.zhaoyh.com.cn/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E7%94%A8%E9%93%BESleuth%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E8%A7%A3%E6%9E%90/</id>
    <published>2020-05-14T07:46:21.000Z</published>
    <updated>2023-06-07T00:55:37.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-调用链初探"><a href="#1-调用链初探" class="headerlink" title="1. 调用链初探"></a>1. 调用链初探</h3><h4 id="1-1-调用链说明"><a href="#1-1-调用链说明" class="headerlink" title="1.1 调用链说明"></a>1.1 调用链说明</h4><p>微服务结构从广义上来说属于分布式架构，在划分微服务节点时，我们通常按业务来区分。每一个逻辑上的业务对应一个服务单元，每个服务单元包含一个至多个服务节点。但是随着业务的复杂度越来越高，服务单元部署的越来越多，服务单元之间的耦合性变得不可控，问题定位也就越来越难。假如一个服务单元A，需要调用多个服务单元，多个服务单元又调用了其他服务单元，那么就产生了一系列的技术痛点：</p><span id="more"></span><ul><li>如何记录一条请求链路的调用流程、调用顺序、每个服务单元的处理时间；</li><li>异常日志需要搜索线上机器位置，定位哪里出错的时间长；</li><li>一些异常错误被大事化小、小事化了，最后不了了之，最后甩锅给了客户端、网络问题、机器问题等。</li></ul><p>分布式调用链路追踪就是为了解决上述问题所提出的，目前，市面上比较热门的分布式调用链解决方案主要有如下几种：</p><table><thead><tr><th>解决方案名</th><th>贡献者</th><th>简介说明</th></tr></thead><tbody><tr><td><a href="https://zipkin.io/">Zipkin</a></td><td>Twitter</td><td>开源，Spring Cloud Sleuth依赖其实现，无代码入侵</td></tr><tr><td><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36356.pdf">Dapper</a></td><td>Google</td><td>定义OpenTracing标准，未开源</td></tr><tr><td><a href="https://github.com/dianping/cat">CAT</a></td><td>美团点评</td><td>开源，完全国产</td></tr><tr><td><a href="http://jm.taobao.org/2014/03/04/3465/">EagleEye</a></td><td>阿里中间件</td><td>未开源</td></tr><tr><td><a href="https://naver.github.io/pinpoint/">Pinpoint</a></td><td>Naver</td><td>成熟度很高的APM调用链监控项目，开源</td></tr><tr><td><a href="https://skywalking.apache.org/zh/">SkyWalking</a></td><td>SkyWalking管理委员会&#x2F;Apache基金会</td><td>开源</td></tr></tbody></table><h4 id="1-2-方案选择考量"><a href="#1-2-方案选择考量" class="headerlink" title="1.2 方案选择考量"></a>1.2 方案选择考量</h4><p>如何选择一款分布式调用链解决方案，笔者总结应考虑如下几点：</p><ul><li>代码入侵性，作为一个与业务无关的组件，应对具体的业务透明，尽可能减少入侵业务系统，降低开发者的负担；</li><li>低损耗性，记录调用链本身会带来系统的性能损耗，在生产环境中，需要组件支持可配置的采样率来应对调用链组件可能产生的损耗问题；</li><li>可扩展性，一个优秀的调用链系统必须支持分布式部署，具备良好的可扩展性；</li><li>与当前已有组件的可兼容性，调用链系统，应当适合当前已有的诸如MQ、数据库等存储组件，减少后续运维开发的负担，不能为了只上一个调用链系统，而要部署一大堆新的环境；</li><li>计算和展示，汇总各个应用程序的调用链日志后，需要完善的查询和展示工具，来对调用链进行分析；</li></ul><p>综合以上几点因素，加上笔者本身在生产环境下使用Spring Boot构建项目居多，最终选择了Zipkin作为我们的分布式链路追踪的解决方案。Sleuth是Spring Cloud提供的，包装了Zipkin的组件包。本文接下来的内容，主要介绍了Sleuth实现Zipkin的细节，以及Zipkin的应用案例。如果你的项目也是基于Spring Boot构建，那直接推荐你使用Sleuth做链路追踪，这样无需改动目前代码，可直接上手。</p><h3 id="2-Sleuth与Zipkin"><a href="#2-Sleuth与Zipkin" class="headerlink" title="2. Sleuth与Zipkin"></a>2. Sleuth与Zipkin</h3><h4 id="2-1-Sleuth与Zipkin关系说明"><a href="#2-1-Sleuth与Zipkin关系说明" class="headerlink" title="2.1 Sleuth与Zipkin关系说明"></a>2.1 Sleuth与Zipkin关系说明</h4><p>Spring Cloud提供了Sleuth作为日志收集工具包，封装了Dapper的标准和Zipkin Client等组件，统一为Spring Cloud应用提供了分布式链路追踪解决方案。本博文之后的代码内容全部依赖于：Spring Cloud + Sleuth + Zipkin + openjdk1.8。</p><h4 id="2-2-OpenTracing术语介绍"><a href="#2-2-OpenTracing术语介绍" class="headerlink" title="2.2 OpenTracing术语介绍"></a>2.2 OpenTracing术语介绍</h4><p>Zipkin的术语代码级别的定义在<a href="https://github.com/openzipkin/zipkin-api/blob/master/thrift/zipkinCore.thrift">这里查看</a></p><h5 id="2-2-1-Annotation"><a href="#2-2-1-Annotation" class="headerlink" title="2.2.1 Annotation"></a>2.2.1 Annotation</h5><p>Annotation用来记录一次调用产生的事件：</p><ul><li>cs，Client Send，客户端发起一个请求；</li><li>sr，Server Received，服务端获得请求并准备开始处理它；</li><li>ss，Server Send，服务端处理完请求并返回；</li><li>cr，Client Receive，客户端收到服务端的返回内容；</li></ul><p>有了上面这四个Annotation，我们就可以提取一次请求链路的关键事件、时间戳、网络延迟等信息。</p><h5 id="2-2-2-Span"><a href="#2-2-2-Span" class="headerlink" title="2.2.2 Span"></a>2.2.2 Span</h5><p>工作单元，你可以理解为对应你的服务单元，调用链每经过一个服务单元，都会产生一个唯一的64位SpanID。</p><h5 id="2-2-3-Trace"><a href="#2-2-3-Trace" class="headerlink" title="2.2.3 Trace"></a>2.2.3 Trace</h5><p>调用链形成的路径，一系列Span组成的树状结构。</p><h5 id="2-2-4-流程分析"><a href="#2-2-4-流程分析" class="headerlink" title="2.2.4 流程分析"></a>2.2.4 流程分析</h5><p>一次典型的调用链产生过程大致为：<br><img src="https://static.zhaoyh.com.cn/1589362601959.jpg" alt="image"></p><ul><li>用户新请求到Service1，本次请求没有trace和span信息，Service1初始化生成自己的traceId&#x3D;X，spanId&#x3D;A；</li><li>Service1继续向Service2发请求，Service2根据发来请求中header信息，提取traceId&#x3D;X，并初始化spanId&#x3D;B；</li><li>Service2继续向Service3发请求，Service3根据请求中的header，提取traceId&#x3D;X，并初始化spanId&#x3D;C；</li></ul><p>这样，我们就可以提取出一个完整的调用链路，路径记录为traceId&#x3D;X，它经过了三个服务单元A-&gt;B-&gt;C，且调用深度为3。链路数据做持久化之后，X作为链路的唯一性ID，可以用来查询链路数据。</p><h3 id="3-Sleuth源码分析"><a href="#3-Sleuth源码分析" class="headerlink" title="3. Sleuth源码分析"></a>3. Sleuth源码分析</h3><p>Sleuth提供了如下一些组件，和目前一些应用做融合：<br><img src="https://static.zhaoyh.com.cn/1589191458165.jpg" alt="image"></p><p>如果你的项目中，用到了图中的组件，都可以无缝支持Sleuth。</p><h4 id="3-1-自动配置"><a href="#3-1-自动配置" class="headerlink" title="3.1 自动配置"></a>3.1 自动配置</h4><p>Sleuth使用起来比较方便，只需要引入相应的包，即可以在应用程序启动的时候自动配置Sleuth，Spring Boot在启动时，会扫描sleuth-core下的<code>spring.factories</code>文件，这里面配置了需要自动装配的bean。Sleuth的自动配置代码在<code>org.springframework.cloud.sleuth.autoconfig</code>包下。我们首先看<code>TraceAutoConfiguration.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.sleuth.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SleuthProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义Tracing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> stable bean name as might be used outside sleuth</span></span><br><span class="line">Tracing <span class="title function_">tracing</span><span class="params">(<span class="meta">@LocalServiceName</span> String serviceName, Propagation.Factory factory,</span></span><br><span class="line"><span class="params">CurrentTraceContext currentTraceContext, Sampler sampler,</span></span><br><span class="line"><span class="params">ErrorParser errorParser, SleuthProperties sleuthProperties,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> List&lt;Reporter&lt;zipkin2.Span&gt;&gt; spanReporters)</span> &#123;</span><br><span class="line">Tracing.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> Tracing.newBuilder().sampler(sampler)</span><br><span class="line">.errorParser(errorParser)</span><br><span class="line">.localServiceName(StringUtils.isEmpty(serviceName) ? DEFAULT_SERVICE_NAME</span><br><span class="line">: serviceName)</span><br><span class="line">.propagationFactory(factory).currentTraceContext(currentTraceContext)</span><br><span class="line">.spanReporter(<span class="keyword">new</span> <span class="title class_">CompositeReporter</span>(<span class="built_in">this</span>.spanAdjusters,</span><br><span class="line">spanReporters != <span class="literal">null</span> ? spanReporters : Collections.emptyList()))</span><br><span class="line">.traceId128Bit(sleuthProperties.isTraceId128())</span><br><span class="line">.supportsJoin(sleuthProperties.isSupportsJoin());</span><br><span class="line"><span class="keyword">for</span> (FinishedSpanHandler finishedSpanHandlerFactory : <span class="built_in">this</span>.finishedSpanHandlers) &#123;</span><br><span class="line">builder.addFinishedSpanHandler(finishedSpanHandlerFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (TracingCustomizer customizer : <span class="built_in">this</span>.tracingCustomizers) &#123;</span><br><span class="line">customizer.customize(builder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(name = TRACER_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">Tracer <span class="title function_">tracer</span><span class="params">(Tracing tracing)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tracing.tracer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个默认的trace采集器bean，默认永远不采集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">Sampler <span class="title function_">sleuthTraceSampler</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Sampler.NEVER_SAMPLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个span名称生成器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">SpanNamer <span class="title function_">sleuthSpanNamer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSpanNamer</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-Web配置"><a href="#3-2-Web配置" class="headerlink" title="3.2 Web配置"></a>3.2 Web配置</h4><p>当启动Web服务时，<code>TraceWebAutoConfiguration.java</code>和<code>TraceWebFluxAutoConfiguration.java</code>会进行一些与Web相关的自动配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.sleuth.web.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(Tracing.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(TraceWebAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceWebFluxAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TraceWebFilter <span class="title function_">traceFilter</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TraceWebFilter</span>(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>TraceWebFilter.java</code>是trace过滤器，对每个http请求过滤，在Spring MVC触发之前，从Request Header中读取trace信息，生成本服务单元的span，没有没有找到相应的header，则初始化新生成一个span。其中初始化Span的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Span <span class="title function_">findOrCreateSpan</span><span class="params">(Context c)</span> &#123;</span><br><span class="line">Span span;</span><br><span class="line"><span class="keyword">if</span> (c.hasKey(TraceContext.class)) &#123;</span><br><span class="line"><span class="type">TraceContext</span> <span class="variable">parent</span> <span class="operator">=</span> c.get(TraceContext.class);</span><br><span class="line">span = <span class="built_in">this</span>.tracer.newChild(parent).start();</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">log.debug(<span class="string">&quot;Found span in reactor context&quot;</span> + span);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.attrSpan != <span class="literal">null</span>) &#123;</span><br><span class="line">span = <span class="built_in">this</span>.attrSpan;</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">log.debug(<span class="string">&quot;Found span in attribute &quot;</span> + span);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">span = <span class="built_in">this</span>.handler.handleReceive(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WrappedRequest</span>(<span class="built_in">this</span>.exchange.getRequest()));</span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">log.debug(<span class="string">&quot;Handled receive of span &quot;</span> + span);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.exchange.getAttributes().put(TRACE_REQUEST_ATTR, span);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-Zuul网关配置"><a href="#3-3-Zuul网关配置" class="headerlink" title="3.3 Zuul网关配置"></a>3.3 Zuul网关配置</h4><p>和网关组件有关的配置，在<code>org.springframework.cloud.sleuth.instrument.zuul</code>包下，在<code>TracePostZuulFilter.java</code>中，配置了网关的后置过滤器，用来传递trace信息给下游。Sleuth通过Request Header传送trace信息，主要包装以下几个参数到header：</p><ul><li>x-b3-traceid</li><li>x-b3-spanid</li><li>x-b3-parentspanid</li><li>x-b3-sampled</li></ul><h4 id="3-4-RPC自动配置"><a href="#3-4-RPC自动配置" class="headerlink" title="3.4 RPC自动配置"></a>3.4 RPC自动配置</h4><p>Sleuth支持RPC的自动配置代码，在<code>TraceRpcAutoConfiguration.java</code>和<code>TraceGrpcAutoConfiguration.java</code>。<br>其中，TraceRpcAutoConfiguration中定义了普通了RpcTracing，TraceGrpcAutoConfiguration中定义了GrpcTracing。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(&#123; GrpcTracing.class, GRpcGlobalInterceptor.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.sleuth.grpc.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(RpcTracing.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(TraceRpcAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceGrpcAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GrpcTracing <span class="title function_">grpcTracing</span><span class="params">(RpcTracing rpcTracing)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GrpcTracing.create(rpcTracing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a global interceptor for both the server</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@GRpcGlobalInterceptor</span></span><br><span class="line">ServerInterceptor <span class="title function_">grpcServerBraveInterceptor</span><span class="params">(GrpcTracing grpcTracing)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> grpcTracing.newServerInterceptor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is wrapper around gRPC&#x27;s managed channel builder that is spring-aware</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(SpringAwareManagedChannelBuilder.class)</span></span><br><span class="line"><span class="keyword">public</span> SpringAwareManagedChannelBuilder <span class="title function_">managedChannelBuilder</span><span class="params">(</span></span><br><span class="line"><span class="params">Optional&lt;List&lt;GrpcManagedChannelBuilderCustomizer&gt;&gt; customizers)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringAwareManagedChannelBuilder</span>(customizers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">GrpcManagedChannelBuilderCustomizer <span class="title function_">tracingManagedChannelBuilderCustomizer</span><span class="params">(</span></span><br><span class="line"><span class="params">GrpcTracing grpcTracing)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TracingManagedChannelBuilderCustomizer</span>(grpcTracing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-Log自动配置"><a href="#3-5-Log自动配置" class="headerlink" title="3.5 Log自动配置"></a>3.5 Log自动配置</h4><p>Sleuth默认支持Slf4j日志组件，Slf4j中定义的MDC(Mapped Diagnostic Contexts)，通过MDC的put方法，可以实现用户自定义的日志输出。我们看一下<code>org.springframework.cloud.sleuth.log.SleuthLogAutoConfiguration</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.sleuth.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(TraceAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleuthLogAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration for Slfj4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(MDC.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SleuthSlf4jProperties.class)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Slf4jConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.sleuth.log.slf4j.enabled&quot;,</span></span><br><span class="line"><span class="meta">matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> CurrentTraceContext.ScopeDecorator <span class="title function_">slf4jSpanDecorator</span><span class="params">(</span></span><br><span class="line"><span class="params">SleuthProperties sleuthProperties,</span></span><br><span class="line"><span class="params">SleuthSlf4jProperties sleuthSlf4jProperties)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Slf4jScopeDecorator</span>(sleuthProperties, sleuthSlf4jProperties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Slf4jScopeDecorator</code>中，MDC的配置方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">traceIdString</span> <span class="operator">=</span> currentSpan.traceIdString();</span><br><span class="line">MDC.put(<span class="string">&quot;traceId&quot;</span>, traceIdString);</span><br><span class="line"><span class="type">String</span> <span class="variable">parentId</span> <span class="operator">=</span> currentSpan.parentId() != <span class="literal">null</span></span><br><span class="line">? HexCodec.toLowerHex(currentSpan.parentId()) : <span class="literal">null</span>;</span><br><span class="line">replace(<span class="string">&quot;parentId&quot;</span>, parentId);</span><br><span class="line">replace(LEGACY_PARENT_ID_NAME, parentId);</span><br><span class="line"><span class="type">String</span> <span class="variable">spanId</span> <span class="operator">=</span> HexCodec.toLowerHex(currentSpan.spanId());</span><br><span class="line">MDC.put(<span class="string">&quot;spanId&quot;</span>, spanId);</span><br><span class="line">MDC.put(LEGACY_SPAN_ID_NAME, spanId);</span><br><span class="line"><span class="type">String</span> <span class="variable">sampled</span> <span class="operator">=</span> String.valueOf(currentSpan.sampled());</span><br><span class="line">MDC.put(<span class="string">&quot;spanExportable&quot;</span>, sampled);</span><br><span class="line">MDC.put(LEGACY_EXPORTABLE_NAME, sampled);</span><br></pre></td></tr></table></figure><p>在logback.xml 文件中通过配置pattern，就可以取出对应的属性值并打印（其实不用单独配置，logback已经帮你默认配置好了，在这里只是给大家传递log打印配置的概念）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%X&#123;parentId&#125;][%X&#123;spanId&#125;][%X&#123;spanExportable&#125;][%thread]%-5level - %logger - %msg%n&lt;/pattern&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你没有做自定义log配置，默认的Sleuth+Slf4j的日志打印案例为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-05-12 17:19:17.079  INFO [test-client-name,f9cf11d6048dce73,35b0b61343412bc6,true] 83396 --- [io-12111-exec-5] com.zhaoyh.controller.MainController     : your logs...</span><br></pre></td></tr></table></figure><ul><li>test-client-name，即配置文件中的applicationName；</li><li>f9cf11d6048dce73，即traceId；</li><li>35b0b61343412bc6，即spanId；</li><li>true&#x2F;false，是否输出到Zipkin Server；</li></ul><h3 id="4-使用总结"><a href="#4-使用总结" class="headerlink" title="4. 使用总结"></a>4. 使用总结</h3><h4 id="4-1-Sleuth使用的优势"><a href="#4-1-Sleuth使用的优势" class="headerlink" title="4.1 Sleuth使用的优势"></a>4.1 Sleuth使用的优势</h4><ul><li>对Web、RPC、Log做了较好的封装，在很小的代码入侵条件下，实现了对调用链的拦截和保存；</li><li>上手容易，Spring Cloud提供了Sleuth来封装Zipkin，对开发人员及其友好，对于基本的日志需求，只需要引入相关的pom即可；</li><li>链路数据存储支持ES、MySQL、Cassandra、内存等，这些基本覆盖了我们的需求；</li><li>社区活跃度较高，得益于Spring Cloud的广泛应用，Sleuth的用户也相应的较多；</li></ul><h4 id="4-2-Sleuth的不足"><a href="#4-2-Sleuth的不足" class="headerlink" title="4.2 Sleuth的不足"></a>4.2 Sleuth的不足</h4><ul><li>Sleuth没有提供全局的调用统计，即某个接口的吞吐量、平均时延等信息无法提供；</li><li>没有提供接口报警机制，出现了有问题的接口调用，只能开发人员主动查询；</li></ul><h3 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h3><ol><li><a href="https://cloud.spring.io/spring-cloud-sleuth/reference/html/">Spring Cloud Sleuth</a></li><li><a href="https://research.google/pubs/pub36356/">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a></li><li><a href="https://zhaoyh.com.cn/2018/12/11/Spring-Cloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E6%9C%8D%E5%8A%A1Sleuth/">Spring Cloud之分布式链路跟踪服务Sleuth</a></li><li><a href="https://zipkin.io/">Zipkin</a></li></ol><blockquote><p>以上内容就是关于分布式调用链Sleuth服务应用及解析的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-调用链初探&quot;&gt;&lt;a href=&quot;#1-调用链初探&quot; class=&quot;headerlink&quot; title=&quot;1. 调用链初探&quot;&gt;&lt;/a&gt;1. 调用链初探&lt;/h3&gt;&lt;h4 id=&quot;1-1-调用链说明&quot;&gt;&lt;a href=&quot;#1-1-调用链说明&quot; class=&quot;headerlink&quot; title=&quot;1.1 调用链说明&quot;&gt;&lt;/a&gt;1.1 调用链说明&lt;/h4&gt;&lt;p&gt;微服务结构从广义上来说属于分布式架构，在划分微服务节点时，我们通常按业务来区分。每一个逻辑上的业务对应一个服务单元，每个服务单元包含一个至多个服务节点。但是随着业务的复杂度越来越高，服务单元部署的越来越多，服务单元之间的耦合性变得不可控，问题定位也就越来越难。假如一个服务单元A，需要调用多个服务单元，多个服务单元又调用了其他服务单元，那么就产生了一系列的技术痛点：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Cloud" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Cloud/"/>
    
    
    <category term="Sleuth" scheme="http://blog.zhaoyh.com.cn/tags/Sleuth/"/>
    
    <category term="Zipkin" scheme="http://blog.zhaoyh.com.cn/tags/Zipkin/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能及GC调优</title>
    <link href="http://blog.zhaoyh.com.cn/2020/03/18/JVM%E6%80%A7%E8%83%BD%E5%8F%8AGC%E8%B0%83%E4%BC%98/"/>
    <id>http://blog.zhaoyh.com.cn/2020/03/18/JVM%E6%80%A7%E8%83%BD%E5%8F%8AGC%E8%B0%83%E4%BC%98/</id>
    <published>2020-03-18T14:19:01.000Z</published>
    <updated>2023-06-07T00:55:37.996Z</updated>
    
    <content type="html"><![CDATA[<p>当线上Java程序性能逐渐下降，通过一系列优化手段也提升有限时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化。从性能来说，GC调优主要关注以下三个评分指标：内存占用、延迟、吞吐量。影响GC性能的参数众多，且参数调整又依赖于应用各自的特点，这些因素很大程度上增加了GC优化的难度，本文介绍了线上GC调优需要学习的一些知识点。</p><span id="more"></span><h3 id="1-Java运行参数设置及优化"><a href="#1-Java运行参数设置及优化" class="headerlink" title="1. Java运行参数设置及优化"></a>1. Java运行参数设置及优化</h3><p>Java运行时数据区如图所示：</p><p><img src="https://static.zhaoyh.com.cn/JVM_5_zone_heap.png" alt="image"></p><p>我们常说的GC大部分指的是Java Heap的一系列操作。本文的所有操作，是基于JDK1.8版本的。</p><h4 id="1-1-堆参数"><a href="#1-1-堆参数" class="headerlink" title="1.1 堆参数"></a>1.1 堆参数</h4><ul><li><strong>-Xms</strong>，堆的初始值，等价于-XX:InitialHeapSize，比如-Xms512m表示初始堆大小为512Mb，-Xms4g表示初始堆大小4g；</li><li><strong>-Xmx</strong>，堆的最大值，等价于 -XX:MaxHeapSize，-Xmx8g表示最大堆为8g；</li><li><strong>-Xmn</strong>，新生代及年轻代大小，则老年代的大小&#x3D;Xmx-Xmn；</li><li><strong>-XX:SurvivorRatio</strong>，年轻代中Eden区所占比例，默认是8，也就是Eden默认占80%；</li></ul><blockquote><p>最好将 -Xms 和 -Xmx 的值设置成一样的值，这样做是为了防止随着堆空间使用量增加，会动态的调整堆空间大小，有一定的性能损耗，不如开始就设置成相同的值，来规避性能损失。</p></blockquote><h4 id="1-2-栈参数"><a href="#1-2-栈参数" class="headerlink" title="1.2 栈参数"></a>1.2 栈参数</h4><ul><li><strong>-Xss</strong>，栈空间大小，栈是线程独占的，所以是一个线程使用栈空间的大小，默认值是1M；</li></ul><blockquote><p>Each thread in a Java application has its own stack. The stack is used to hold return addresses, function&#x2F;method call arguments, etc. So if a thread tends to process large structures via recursive algorithms, it may need a large stack for all those return addresses and such. With the Sun JVM, you can set that size via that parameter.</p></blockquote><h4 id="1-3-Metaspace参数"><a href="#1-3-Metaspace参数" class="headerlink" title="1.3 Metaspace参数"></a>1.3 Metaspace参数</h4><ul><li><strong>-XX:MetaspaceSize</strong>，Metaspace空间初始大小，默认是20.79M，这个初始大小是触发首次Metaspace Full GC的阈值，配置案例如 -XX:MetaspaceSize&#x3D;256M；</li><li><strong>-XX:MaxMetaspaceSize</strong>，Metaspace 最大值，默认不限制大小；</li><li><strong>-XX:MinMetaspaceFreeRatio</strong>，最小空闲比，当Metaspace发生GC后，会计算Metaspace 的空闲比，如果空闲比(空闲空间&#x2F;当前Metaspace大小)小于此值，就会触发Metaspace扩容。默认值是40 ，也就是40%，配置案例如 -XX:MinMetaspaceFreeRatio&#x3D;40；</li><li><strong>-XX:MaxMetaspaceFreeRatio</strong>，最大空闲比，当Metaspace发生GC后，会计算Metaspace的空闲比，如果空闲比(空闲空间&#x2F;当前Metaspace大小)大于此值，就会触发Metaspace释放空间。默认值是70 ，也就是70%，配置案例如 -XX:MaxMetaspaceFreeRatio&#x3D;70；</li></ul><h4 id="1-4-JVM运行配置参数"><a href="#1-4-JVM运行配置参数" class="headerlink" title="1.4 JVM运行配置参数"></a>1.4 JVM运行配置参数</h4><ul><li><strong>-verbose:gc或-XX:+PrintGC</strong>，简单输出GC日志；</li><li><strong>-Xloggc:&#x2F;logs&#x2F;gc.log</strong>，GC日志输出位置；</li><li><strong>-XX:+PrintGCDetails</strong>，输出GC详细日志；</li><li><strong>-XX:+PrintGCDateStamps</strong>，输出GC的时间戳，以日期的形式，如2020-03-11T17:22:48.180+0800；</li><li><strong>-XX:+PrintGCTimeStamps</strong>，输出GC的时间戳；</li><li><strong>-XX:+PrintHeapAtGC</strong>，在进行GC的前后打印出堆的信息；</li><li><strong>-XX:+PrintGCApplicationStoppedTime</strong>，打印GC导致的Stop The World时间；</li><li><strong>-XX:+PrintClassHistogramBeforeFullGC</strong>和<strong>XX:+PrintClassHistogramAfterFullGC</strong>，GC前后的类加载情况；</li><li><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>，内存溢出时自动导出，内存很大的时候，可能会导不出来，使用<strong>XX:HeapDumpPath&#x3D;dir</strong>导出内存映像文件；</li></ul><h4 id="1-5-设置垃圾回收器"><a href="#1-5-设置垃圾回收器" class="headerlink" title="1.5 设置垃圾回收器"></a>1.5 设置垃圾回收器</h4><p>JDK8可使用的垃圾收集器有7种，当然有的只适用于年轻代，有的只适用于老年代，JDK8中最新的垃圾收集器是G1，可以用于年轻代和老年代，到了JDK11，还出了ZGC。</p><ul><li><strong>-XX:+UseSerialGC</strong>，虚拟机Client模式下的默认值，使用Serial（新生代）+ Serial Old（老年代）收集器；</li><li><strong>-XX:+UseParNewGC</strong>，使用ParNew + Serial Old，JDK9后不再支持；</li><li><strong>-XX:+UseConcMarkSweepGC</strong>，使用ParNew + CMS + Serial Old组合收集器，Serial Old作为CMS出现“Concurrent Mode Failure”错误后的备选；</li><li><strong>-XX:+UseParallelGC</strong>，使用Parallel Scavenge（新生代） + Serial Old（老年代）收集器，JDK9之前Server模式下的默认设置；</li><li><strong>-XX:+UseParallelOldGC</strong>，使用Parallel Scavenge（新生代） + Parallel Old（老年代）收集器；</li><li><strong>-XX:+UseG1GC</strong>，使用G1垃圾收集器，JDK9之后的Server模式默认值；</li></ul><h4 id="1-6-远程JMX设置"><a href="#1-6-远程JMX设置" class="headerlink" title="1.6 远程JMX设置"></a>1.6 远程JMX设置</h4><p>当我们需要查看JVM运行状态，第一种是登陆JVM服务器，使用jmap、jstack、jstat等工具查看；第二种是开启JMX远程功能，使用jConsole、VisualVM等工具进行监控。开启的参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">#指定jvm所在服务器ip或域名</span><br><span class="line">-Djava.rmi.server.hostname=192.168.1.1</span><br><span class="line">#指定端口</span><br><span class="line">-Dcom.sun.management.jmxremote.port=9999</span><br><span class="line">-Dcom.sun.management.jmxremote.rmi.port=9999</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false</span><br></pre></td></tr></table></figure><h3 id="2-GC日志分析"><a href="#2-GC日志分析" class="headerlink" title="2. GC日志分析"></a>2. GC日志分析</h3><h4 id="2-1-Young-GC日志"><a href="#2-1-Young-GC日志" class="headerlink" title="2.1 Young GC日志"></a>2.1 Young GC日志</h4><p>一段典型的Young GC(Minor GC)的日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-03-11T17:43:28.034+0800: 20595.056: [GC (Allocation Failure) [PSYoungGen: 4185120K-&gt;4923K(4188160K)] 4547662K-&gt;368154K(8382464K), 0.0071567 secs] [Times: user=0.13 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>Young GC说明图示：</p><p><img src="https://static.zhaoyh.com.cn/Young_GC_detail.png" alt="image"></p><h4 id="2-2-Full-GC日志"><a href="#2-2-Full-GC日志" class="headerlink" title="2.2 Full GC日志"></a>2.2 Full GC日志</h4><p>Full GC日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-01-10T16:53:43.811+0800: 980.825: [Full GC (Metadata GC Threshold) [PSYoungGen: 21613K-&gt;0K(231424K)] [ParOldGen: 390439K-&gt;400478K(761856K)] 412053K-&gt;400478K(993280K), [Metaspace: 314108K-&gt;313262K(1458176K)], 1.2320834 secs] [Times: user=7.86 sys=0.06, real=1.23 secs]</span><br></pre></td></tr></table></figure><p>Full GC说明图示：</p><p><img src="https://static.zhaoyh.com.cn/Full_GC_detail.png" alt="image"></p><h4 id="2-3-GC日志分析工具"><a href="#2-3-GC日志分析工具" class="headerlink" title="2.3 GC日志分析工具"></a>2.3 GC日志分析工具</h4><p><strong>GChisto</strong>，是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况：</p><p><img src="https://static.zhaoyh.com.cn/gchisto_show_detail.jpg" alt="image"></p><p><a href="https://gceasy.io/">GC Easy</a>是一款在线的GC日志分析工具，将gc的log上传后，直接查看结果：</p><p><img src="https://static.zhaoyh.com.cn/1583920580315.jpg" alt="image"><br><img src="https://static.zhaoyh.com.cn/1583920627496.jpg" alt="image"></p><h3 id="3-常用JDK工具"><a href="#3-常用JDK工具" class="headerlink" title="3. 常用JDK工具"></a>3. 常用JDK工具</h3><h4 id="3-1-可视化工具类"><a href="#3-1-可视化工具类" class="headerlink" title="3.1 可视化工具类"></a>3.1 可视化工具类</h4><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jconsole.html">jconsole</a></td><td>用于监控Java虚拟机的使用JMX规范的图形工具。它可以监控本地和远程JVM。它还可以监控和管理应用程序。</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jconsole.html">jvisualvm</a></td><td>提供内存和CPU分析，堆转储分析，内存泄漏检测等监控。</td></tr></tbody></table><h4 id="3-2-监控类"><a href="#3-2-监控类" class="headerlink" title="3.2 监控类"></a>3.2 监控类</h4><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">jstat</a>是查看JVM统计信息的工具，jstat的命令格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstat [options] pid [interval] [count]</span><br><span class="line"></span><br><span class="line">options，一般使用 -gcutil 或 -gc 查看gc情况</span><br><span class="line">pid，当前运行的Java进程号</span><br><span class="line">interval，间隔时间，单位为秒或者毫秒</span><br><span class="line">count，打印次数，如果缺省则打印无数次</span><br></pre></td></tr></table></figure><p>options参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-gc：统计 jdk gc时 heap信息，以使用空间字节数表示</span><br><span class="line">-gcutil：统计 gc时 heap情况，以使用空间的百分比表示</span><br><span class="line">-class：统计 class loader行为信息</span><br><span class="line">-compile：统计编译行为信息</span><br><span class="line">-gccapacity：统计不同 generations（新生代，老年代，持久代）的容量使用的最大最小值，例如使用到的最大值、最小值、当前使用值等等</span><br><span class="line">-gccause：统计引起 gc的事件</span><br><span class="line">-gcnew：统计 gc时，新生代的情况</span><br><span class="line">-gcnewcapacity：统计 gc时，新生代 heap容量</span><br><span class="line">-gcold：统计 gc时，老年代的情况</span><br><span class="line">-gcoldcapacity：统计 gc时，老年代 heap容量</span><br><span class="line">-gcpermcapacity：统计 gc时， permanent区 heap容量</span><br></pre></td></tr></table></figure><p>以jstat -gc 60067 10000 5命令为例，运行结果为：</p><p><img src="https://static.zhaoyh.com.cn/1583920944220.jpg" alt="image"></p><p>每一列的含义为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">S0C: 第1个Survivor空间的容量 Current survivor space 0 capacity (kB).</span><br><span class="line">S1C: 第2个Survivor空间的容量(kB).</span><br><span class="line">S0U: 第1个Survivor空间中已经使用的容量 Survivor space 0 utilization (kB).</span><br><span class="line">S1U: 第2个Survivor空间中已经使用的容量(kB).</span><br><span class="line">EC: Eden空间的容量(kB).</span><br><span class="line">EU: Eden空间中已经使用的容量(kB).</span><br><span class="line">OC: 老年代Old空间的容量(kB).</span><br><span class="line">OU: 老年代Old空间已经使用的容量(kB).</span><br><span class="line">MC: 元空间Metaspace的容量(kB).</span><br><span class="line">MU: 元空间Metaspace已经使用的容量(kB).</span><br><span class="line">CCSC: 压缩类空间的容量 Compressed class space capacity (kB).</span><br><span class="line">CCSU: 压缩类空间已经使用的容量(kB).</span><br><span class="line">YGC: Young GC发生的次数.</span><br><span class="line">YGCT: Young GC花费的时间.</span><br><span class="line">FGC: Full GC发生的次数.</span><br><span class="line">FGCT: Full GC花费的时间.</span><br><span class="line">GCT: 所有的GC花费的总时间.</span><br></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html">jps</a>是进程状态工具(JVM Process Status Tool)，在目标系统上列出HotSpot Java虚拟机进程的描述信息。</p><h4 id="3-3-故障分析类"><a href="#3-3-故障分析类" class="headerlink" title="3.3 故障分析类"></a>3.3 故障分析类</h4><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html">jinfo</a></td><td>Java的配置信息工具(Java Configuration Information)，用于打印指定Java进程、核心文件或远程调试服务器的配置信息。</td></tr><tr><td><a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html">jhat</a></td><td>Java堆分析工具(Java Heap Analysis Tool)，用于分析Java堆内存中的对象信息。</td></tr><tr><td><a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html">jmap</a></td><td>Java内存映射工具(Java Memory Map)，主要用于打印指定Java进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节，打印内存dump文件等。</td></tr><tr><td><a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html">jstack</a></td><td>Java的堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息。</td></tr></tbody></table><h4 id="3-4-其他"><a href="#3-4-其他" class="headerlink" title="3.4 其他"></a>3.4 其他</h4><p><a href="https://arthas.aliyun.com/doc/quick-start.html">Arthas</a>是Alibaba开源的Java诊断工具，深受开发者喜爱。支持在线排查程序问题，无需重启，可动态跟踪Java代码，可实时监控JVM状态。支持Linux&#x2F;Mac&#x2F;Windows，采用命令行交互模式，同时提供丰富的Tab自动补全功能，进一步方便进行问题的定位和诊断。</p><h3 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h3><ul><li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li><li><a href="https://www.jianshu.com/p/676486f029e7">Java生产环境下性能监控与调优详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/91757020">JVM中你不可不知的参数</a></li></ul><blockquote><p>以上内容就是关于JVM性能及GC调优的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;当线上Java程序性能逐渐下降，通过一系列优化手段也提升有限时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化。从性能来说，GC调优主要关注以下三个评分指标：内存占用、延迟、吞吐量。影响GC性能的参数众多，且参数调整又依赖于应用各自的特点，这些因素很大程度上增加了GC优化的难度，本文介绍了线上GC调优需要学习的一些知识点。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM系列" scheme="http://blog.zhaoyh.com.cn/categories/JVM%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="垃圾回收" scheme="http://blog.zhaoyh.com.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="GC" scheme="http://blog.zhaoyh.com.cn/tags/GC/"/>
    
    <category term="JDK工具" scheme="http://blog.zhaoyh.com.cn/tags/JDK%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(七)之基于Dubbo和Seata的分布式事务解决方案</title>
    <link href="http://blog.zhaoyh.com.cn/2019/08/14/Spring%20Boot(%E4%B8%83)%E4%B9%8B%E5%9F%BA%E4%BA%8EDubbo%E5%92%8CSeata%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.zhaoyh.com.cn/2019/08/14/Spring%20Boot(%E4%B8%83)%E4%B9%8B%E5%9F%BA%E4%BA%8EDubbo%E5%92%8CSeata%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2019-08-14T08:44:32.000Z</published>
    <updated>2023-06-07T00:55:37.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分布式事务初探"><a href="#1-分布式事务初探" class="headerlink" title="1. 分布式事务初探"></a>1. 分布式事务初探</h3><p>一般来说，目前市面上的数据库都支持<strong>本地事务</strong>，也就是在你的应用程序中，在一个数据库连接下的操作，可以很容易的实现事务的操作。但是目前，基于SOA的思想，大部分项目都采用微服务架构后，就会出现了跨服务间的事务需求，这就称为<strong>分布式事务</strong>。本文假设你已经了解了事务的运行机制，如果你不了解事务，那么我建议先去看下事务相关的文章，再来阅读本文。</p><span id="more"></span><h4 id="1-1-什么是分布式事务"><a href="#1-1-什么是分布式事务" class="headerlink" title="1.1 什么是分布式事务"></a>1.1 什么是分布式事务</h4><p>对于传统的单体应用而言，实现<strong>本地事务</strong>可以依赖Spring的<code>@Transactional</code>注解标识方法，实现事务非常简单。</p><p>我们以最常见的电商系统为例，简单拆分为客户端、订单服务、库存服务、等，在用户下单过程中，需要同时调用各个服务，但是，每个服务都是独立部署的，数据库连接是不共享的，因此要保证这些操作全部执行，或者全部不执行，就需要<strong>分布式事务</strong>的支持。</p><h4 id="1-2-分布式事务解决方案"><a href="#1-2-分布式事务解决方案" class="headerlink" title="1.2 分布式事务解决方案"></a>1.2 分布式事务解决方案</h4><p>目前通用的分布式事务解决方案主要有：</p><ul><li>全局事务，基于DTP模型实现，需要三种角色即Application应用系统（客户端），Transaction Manager 事务管理器，Resource Manager资源管理器；</li><li>基于可靠消息服务的分布式事务，通过消息队列实现事务的一致性；</li><li>TCC，即Try、Confirm、Cancel，属于补偿型分布式事务，Try：尝试待执行的事务，Confirm：执行事务，Cancel：取消执行的事务；</li></ul><h4 id="1-3-Seata介绍"><a href="#1-3-Seata介绍" class="headerlink" title="1.3 Seata介绍"></a>1.3 Seata介绍</h4><p>Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。Seata于2019.1正式对外开源，前身是阿里巴巴2014年诞生的TXC（Taobao Transaction Constructor）。以下是Seata官网介绍的特色服务：<br><img src="https://static.zhaoyh.com.cn/1565622300923.jpg" alt="image">。</p><p>Seata为用户提供了AT、TCC 和 XA事务模式，为用户打造一站式的分布式解决方案。更多关于Seata的介绍，可参考其<a href="https://seata.io/zh-cn/docs/overview/what_is_seata.html">官网</a></p><h3 id="2-分布式事务案例"><a href="#2-分布式事务案例" class="headerlink" title="2. 分布式事务案例"></a>2. 分布式事务案例</h3><h4 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h4><p>运行本案例，需要你提前准备如下的软件运行环境：</p><table><thead><tr><th>运行环境</th><th>版本要求</th></tr></thead><tbody><tr><td>jdk</td><td>1.8+</td></tr><tr><td>Spring Boot</td><td>1.5+</td></tr><tr><td>MySQL</td><td>5.7+</td></tr><tr><td>ZooKeeper</td><td>3.4+</td></tr><tr><td>Seata</td><td>0.6.1</td></tr><tr><td>Dubbo</td><td>2.6.5</td></tr></tbody></table><p>本案例，主要模仿简单的下单扣减库存的过程，架构图如下：<br><img src="https://static.zhaoyh.com.cn/1565769687553.jpg" alt="image"></p><h4 id="2-2-Seata管理端"><a href="#2-2-Seata管理端" class="headerlink" title="2.2 Seata管理端"></a>2.2 Seata管理端</h4><p>下载<a href="https://github.com/seata/seata/releases">Seata</a>的最新版本，并解压后，进入seata&#x2F;bin目录，启动Seata服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh seata-server.sh 8091 file</span><br></pre></td></tr></table></figure><p>读取本地文件作为Seata的配置中心，Seata还支持nacos、consul、apollo、etcd、zookeeper这些配置中心。</p><h4 id="2-3-数据表"><a href="#2-3-数据表" class="headerlink" title="2.3 数据表"></a>2.3 数据表</h4><p>本测试服务，需要创建两张业务表，分别是订单表和库存表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `order_no` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `commodity_code` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `amount` <span class="keyword">double</span>(<span class="number">14</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_storage` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `commodity_code` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `commodity_code` (`commodity_code`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>Seata AT模式需要创建UNDO_LOG表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><h4 id="2-4-构建Spring-Boot服务"><a href="#2-4-构建Spring-Boot服务" class="headerlink" title="2.4 构建Spring Boot服务"></a>2.4 构建Spring Boot服务</h4><p>示例代码可参考<a href="https://github.com/chadwick521/springboot-seata-project">Github仓库</a>，仓库的目录结构如下：<br><img src="https://static.zhaoyh.com.cn/1565769114443.jpg" alt="image"></p><ul><li>springboot-base：存储公共调用的基类接口，mapper接口，Model层的类等，可mvn install后，供另外三个module调用。</li><li>springboot-dubbo-storage：库存服务；</li><li>springboot-dubbo-order：订单服务；</li><li>springboot-dubbo-client：RPC消费者，提供对外接口；</li></ul><p>基于Spring Boot构建Dubbo服务可参考之前的博文<a href="https://reurl.cc/EG2W6m">Spring Boot(五)之集成Dubbo部署RPC服务</a>，构建本项目的过程就不再赘述了。</p><p>加入Seata组件，与普通Dubbo项目的不同之处在于：</p><ol><li>配置Seata数据源：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * seata数据源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * init datasource proxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span>: druidDataSource  datasource bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span>: DataSourceProxy  datasource proxy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSourceProxy <span class="title function_">dataSourceProxy</span><span class="params">(DruidDataSource druidDataSource)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProxy</span>(druidDataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Seata初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置全局事务扫描器。有两个参数，一个是应用名称，一个是事务分组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GlobalTransactionScanner <span class="title function_">globalTransactionScanner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GlobalTransactionScanner</span>(<span class="string">&quot;springboot-dubbo-storage&quot;</span>, <span class="string">&quot;my_test_tx_group&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>配置注册中心，目前可用的配置中心有file、nacos 、apollo、zk、consul，file类型本身不具备注册中心的动态发现和动态配置功能，官方的初衷是在不依赖第三方配置注册中心的基础上快速集成测试seata功能。配置内容在file.conf和registry.conf。</p></li><li><p>注解标记事务方法，在需要分布式事务的方法上，加上@GlobalTransactional注解即可。</p></li></ol><h4 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h4><p>依次启动Seata、springboot-dubbo-storage、springboot-dubbo-order、springboot-dubbo-client后，打开postman测试，配置测试参数为：</p><p><img src="https://static.zhaoyh.com.cn/1565771778740.jpg" alt="image"></p><p>可以看到，在addOrder接口报错后，会有全局事务的rollback过程日志：</p><p><img src="https://static.zhaoyh.com.cn/1676896288938.jpg" alt="image"></p><h3 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h3><ul><li><a href="https://seata.io/zh-cn/index.html">Seata</a></li><li><a href="https://seata.io/zh-cn/blog/dubbo-seata.html">如何使用Seata保证Dubbo微服务间的一致性</a></li><li><a href="https://juejin.im/post/5d19ee6af265da1bcd37effa">SpringBoot+Dubbo+Seata分布式事务实战</a></li><li><a href="https://mp.weixin.qq.com/s/HyWaYIJIqdLp1c_xrrzY1g">分布式事务选型的取舍</a></li><li><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca">常用的分布式事务解决方案</a></li></ul><blockquote><p>以上内容就是关于Spring-Boot(七)之基于Dubbo和Seata的分布式事务解决方案的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-分布式事务初探&quot;&gt;&lt;a href=&quot;#1-分布式事务初探&quot; class=&quot;headerlink&quot; title=&quot;1. 分布式事务初探&quot;&gt;&lt;/a&gt;1. 分布式事务初探&lt;/h3&gt;&lt;p&gt;一般来说，目前市面上的数据库都支持&lt;strong&gt;本地事务&lt;/strong&gt;，也就是在你的应用程序中，在一个数据库连接下的操作，可以很容易的实现事务的操作。但是目前，基于SOA的思想，大部分项目都采用微服务架构后，就会出现了跨服务间的事务需求，这就称为&lt;strong&gt;分布式事务&lt;/strong&gt;。本文假设你已经了解了事务的运行机制，如果你不了解事务，那么我建议先去看下事务相关的文章，再来阅读本文。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/tags/Spring-Boot/"/>
    
    <category term="Dubbo" scheme="http://blog.zhaoyh.com.cn/tags/Dubbo/"/>
    
    <category term="Seata" scheme="http://blog.zhaoyh.com.cn/tags/Seata/"/>
    
    <category term="事务" scheme="http://blog.zhaoyh.com.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="分布式事务" scheme="http://blog.zhaoyh.com.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud之容错组件Hystrix</title>
    <link href="http://blog.zhaoyh.com.cn/2019/07/31/Spring-Cloud%E4%B9%8B%E5%AE%B9%E9%94%99%E7%BB%84%E4%BB%B6Hystrix/"/>
    <id>http://blog.zhaoyh.com.cn/2019/07/31/Spring-Cloud%E4%B9%8B%E5%AE%B9%E9%94%99%E7%BB%84%E4%BB%B6Hystrix/</id>
    <published>2019-07-31T10:26:15.000Z</published>
    <updated>2023-06-07T00:55:37.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Hystrix介绍"><a href="#1-Hystrix介绍" class="headerlink" title="1. Hystrix介绍"></a>1. Hystrix介绍</h3><h4 id="1-1-初识Hystrix"><a href="#1-1-初识Hystrix" class="headerlink" title="1.1 初识Hystrix"></a>1.1 初识Hystrix</h4><p><a href="https://github.com/Netflix/Hystrix">Hystrix</a>是Netflix开源的容错框架，这是Netflix对其的简短介绍：</p><blockquote><p>Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.</p></blockquote><span id="more"></span><p>可以大致这样理解：分布式系统间的服务调用，不可避免的会出错，Hystrix提供了一套系统的容错、处理错误的方法，来尽量保证你的分布式系统的稳定性。</p><p>以下面这个常见的电商系统服务调用为例：</p><p><img src="https://static.zhaoyh.com.cn/1564559317683.jpg" alt="image"></p><p>假如我们现在有上面三个核心服务：用户服务、订单服务、库存服务，三个服务均是通过HTTP调用。<br><img src="https://static.zhaoyh.com.cn/1564559758768.jpg" alt="image"></p><p>假如库存系统挂了，造成很多的线程阻塞，若后面有很多其他的HTTP请求，将很快造成线程池耗尽，则整个服务对外不可用，这就是微服务系统的雪崩效应。</p><p><img src="https://static.zhaoyh.com.cn/1564559965751.jpg" alt="image"></p><h4 id="1-2-系统容错"><a href="#1-2-系统容错" class="headerlink" title="1.2 系统容错"></a>1.2 系统容错</h4><p>对于1.1中的案例，依赖Hystrix，可以提供一套依赖服务的治理和监控解决方案，Hystrix包含常用的容错方法：线程池隔离、信号量隔离、熔断、降级等。</p><h3 id="2-Spring-Cloud整合Hystrix"><a href="#2-Spring-Cloud整合Hystrix" class="headerlink" title="2. Spring Cloud整合Hystrix"></a>2. Spring Cloud整合Hystrix</h3><h4 id="2-1-创建整合hystrix的项目"><a href="#2-1-创建整合hystrix的项目" class="headerlink" title="2.1 创建整合hystrix的项目"></a>2.1 创建整合hystrix的项目</h4><p>首先创建一个空的Spring Boot项目，在pom.xml中加入如下引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.58<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中spring-cloud-starter-hystrix-dashboard是查看hystrix状态的组件，如不用可不添加。</p><p>主函数中启动hystrix：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure><p>其中@EnableHystrixDashboard是查看hystrix状态的组件，如不用可不添加。</p><p>增加hystrix.stream的servlet，这个同时也是查看hystrix状态的组件，如不用可不添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置hystrix.stream</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">    <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">    registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个基本的RestController类调用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhaoyh on 2019-07-30</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间设置为1000ms</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;onErrors&quot;,</span></span><br><span class="line"><span class="meta">            commandProperties = &#123;@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1000&quot;)&#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getName/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONObject <span class="title function_">getName</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里构造出错的机会，触发fallback</span></span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        json.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;name_&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;onErrors&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getAge/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONObject <span class="title function_">getAge</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里构造出错的机会，触发fallback</span></span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        json.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;age_&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果fallback方法的参数和原方法参数个数不一致</span></span><br><span class="line"><span class="comment">     * 则会出现FallbackDefinitionException: fallback method wasn&#x27;t found</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JSONObject <span class="title function_">onErrors</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        json.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        json.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;执行你需要的默认方法！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，application.properties中的配置为简单的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.port=16091</span><br><span class="line">spring.application.name=springcloud-hystrix-test</span><br></pre></td></tr></table></figure><h4 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h4><p>启动项目，首先打开 <a href="http://localhost:16091/hystrix/">http://localhost:16091/hystrix/</a> ，这是初始的查看hystrix状态的Dashboard：</p><p><img src="https://static.zhaoyh.com.cn/1564482368489.jpg" alt="image"></p><p>当然，如果你在2.1中没有添加spring-cloud-starter-hystrix-dashboard引用，是没有这个页面的。</p><p>把 <a href="http://localhost:16091/hystrix.stream">http://localhost:16091/hystrix.stream</a> 链接贴到dashboard里，命个名之后，就可以看到hystrix的请求数据流了：<br><img src="https://static.zhaoyh.com.cn/1564482542375.jpg" alt="image"></p><p>多请求几次定义的接口，即可看到dashboard有数据了：</p><p><img src="https://static.zhaoyh.com.cn/1564482718032.jpg" alt="image"></p><h4 id="2-3-触发断路器"><a href="#2-3-触发断路器" class="headerlink" title="2.3 触发断路器"></a>2.3 触发断路器</h4><p>请求 <a href="http://localhost:16091/getName/-22">http://localhost:16091/getName/-22</a> ，会抛出异常，模仿我们日常的程序出错：</p><p><img src="https://static.zhaoyh.com.cn/1564486552974.jpg" alt="image"></p><p>多执行几次，然后查看dashboard，发现断路器是open的状态：</p><p><img src="https://static.zhaoyh.com.cn/1564486672083.jpg" alt="image"></p><p>断路器是open的状态后再请求 <a href="http://localhost:16091/getName/-22">http://localhost:16091/getName/-22</a> 都会执行默认的fallback方法，你可以在fallback方法里重写出错后的返回逻辑。</p><p>断路器是closed的状态后所有请求恢复正常。</p><h3 id="3-Hystrix高级篇"><a href="#3-Hystrix高级篇" class="headerlink" title="3. Hystrix高级篇"></a>3. Hystrix高级篇</h3><h4 id="3-1-理解熔断和降级"><a href="#3-1-理解熔断和降级" class="headerlink" title="3.1 理解熔断和降级"></a>3.1 理解熔断和降级</h4><p>理解熔断：以家用电路保险丝为例，当电流过载时，保险丝会自动断掉，以此来保护家用电器。Hystrix中的断路器也是类似的功能，当达到开关阈值时，断路器打开，此时所有请求执行fallback方法；当达到断路器可以关闭的状态时，熔断器closed，此时所有的请求再恢复正常。Hystrix的熔断器状态转换图如下：</p><p><img src="https://static.zhaoyh.com.cn/1564562129509.jpg" alt="image"></p><p>熔断器打开和关闭，都是可配置的，目前，默认的打开和关闭的策略可查询<a href="https://github.com/Netflix/Hystrix/blob/master/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandProperties.java">源代码</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final Integer default_metricsRollingStatisticalWindow = 10000;</span><br><span class="line">private static final Integer default_metricsRollingStatisticalWindowBuckets = 10;</span><br><span class="line">private static final Integer default_circuitBreakerRequestVolumeThreshold = 20;</span><br><span class="line">private static final Integer default_circuitBreakerSleepWindowInMilliseconds = 5000;</span><br><span class="line">private static final Integer default_circuitBreakerErrorThresholdPercentage = 50;</span><br></pre></td></tr></table></figure><p>即：10秒的窗口期内，至少请求20次，且出错比例超过50%，则触发熔断器打开。</p><p>半开状态的试探休眠时间默认值5000ms。当熔断器open一段时间之后比如5000ms，会尝试放过去一部分流量进行试探，确定依赖服务是否恢复。</p><p>理解降级：可以把降级理解为fallback机制，当服务出错时，执行fallback备用方法，可以称为降级机制。</p><h4 id="3-2-线程隔离"><a href="#3-2-线程隔离" class="headerlink" title="3.2 线程隔离"></a>3.2 线程隔离</h4><p>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中&#x2F;信号授权下执行。并将封装好的命令和线程池的对应关系放到一个ConcurrentHashMap&lt;String, HystrixThreadPool&gt;中，这样，每个请求使用独立的线程池处理请求，保证了互相之间不受影响，避免了一个服务出问题后大量线程阻塞的问题。通过设置线程池的合理大小来控制并发访问量，当线程饱和的时候可以拒绝服务，防止依赖问题扩散。</p><p>线程隔离的优点：</p><ul><li>将各个服务保护起来，即使依赖的一个服务的线程池满了，也不会影响到应用程序的其他部分。</li><li>可提供内置的并发功能，使得可以在同步调用之上构建异步的外观模式，这样就可以很方便的做异步编程。</li><li>参数可配置，比如延迟、超时、拒绝等。同时可以通过动态属性实时执行来处理纠正错误的参数配置。</li><li>通过配置合理的线程池大小，实现访问限流。</li></ul><h4 id="3-3-信号量隔离"><a href="#3-3-信号量隔离" class="headerlink" title="3.3 信号量隔离"></a>3.3 信号量隔离</h4><p>当我们依赖的服务是极低延迟的，比如访问内存缓存，就没有必要使用线程池的方式，那样的话开销得不偿失，而是推荐使用信号量这种方式。<br>将属性execution.isolation.strategy设置为SEMAPHORE 就实现了信号量隔离策略，</p><p>线程隔离和信号量隔离的不同可见下图：</p><p><img src="https://static.zhaoyh.com.cn/4098122-ced571958d393bfc.png" alt="image"></p><p>线程隔离策略下业务请求线程和执行调用服务的线程不是同一个线程；信号量方式下业务请求线程和执行调用服务的线程是同一个线程。</p><p>信号量隔离的方式是限制了总的并发数，每一次请求过来，请求线程和调用依赖服务的线程是同一个线程，那么如果不涉及远程RPC调用（没有网络开销）则使用信号量来隔离，更为轻量，开销更小。</p><h3 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4. 参考文档"></a>4. 参考文档</h3><ol><li><a href="https://cloud.spring.io/spring-cloud-netflix/1.4.x/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients">Spring Cloud Netflix</a></li><li><a href="http://www.iocoder.cn/Hystrix/circuit-breaker/">Hystrix源码解析</a></li><li><a href="https://blog.51cto.com/developerycj/1950881">Hystrix 分布式系统限流、降级、熔断框架</a></li><li><a href="http://www.ityouknow.com/springcloud/2017/05/16/springcloud-hystrix.html">springcloud(四)：熔断器Hystrix</a></li></ol><blockquote><p>以上内容就是关于Spring Cloud之容错组件Hystrix的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-Hystrix介绍&quot;&gt;&lt;a href=&quot;#1-Hystrix介绍&quot; class=&quot;headerlink&quot; title=&quot;1. Hystrix介绍&quot;&gt;&lt;/a&gt;1. Hystrix介绍&lt;/h3&gt;&lt;h4 id=&quot;1-1-初识Hystrix&quot;&gt;&lt;a href=&quot;#1-1-初识Hystrix&quot; class=&quot;headerlink&quot; title=&quot;1.1 初识Hystrix&quot;&gt;&lt;/a&gt;1.1 初识Hystrix&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/Hystrix&quot;&gt;Hystrix&lt;/a&gt;是Netflix开源的容错框架，这是Netflix对其的简短介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Spring Cloud" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Cloud/"/>
    
    
    <category term="Hystrix" scheme="http://blog.zhaoyh.com.cn/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud之应用程序多维度监控解决方案</title>
    <link href="http://blog.zhaoyh.com.cn/2019/03/19/Spring-Cloud%E4%B9%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A4%9A%E7%BB%B4%E5%BA%A6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.zhaoyh.com.cn/2019/03/19/Spring-Cloud%E4%B9%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A4%9A%E7%BB%B4%E5%BA%A6%E7%9B%91%E6%8E%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2019-03-19T08:51:03.000Z</published>
    <updated>2023-06-07T00:55:37.967Z</updated>
    
    <content type="html"><![CDATA[<p>使用微服务框架开发应用程序，其特点是分模块、跨进程、分布式部署。这就增加了对整个服务的监控难度，由于分布式服务的“雪崩式效应”，当一个微服务发生故障时，会连带着对整个服务造成不可估量的影响。因此如何快速定位问题，以及查询系统健康程度等就显得尤为必要。系统内及系统间的监控，也是微服务治理的重要组成部分。本文从系统级别和系统间的级别角度，通过笔者在实际生产环境中的应用经验，总结了对Spring Boot应用程序的监控整体多维度解决方案。本文适合Spring Boot开发人员阅读，也适合运维相关的同学阅读，如果你对程序本身的监控感兴趣，也可以尝试去阅读。</p><span id="more"></span><h3 id="1-系统级别监控"><a href="#1-系统级别监控" class="headerlink" title="1. 系统级别监控"></a>1. 系统级别监控</h3><p>系统级别的监控，是应用程序本身的健康程度的直接体现，常用包括JVM、GC、Environment、IO、System Load、Property、ClassLoading等信息。Spring Boot提供了Actuator组件，对应用程序的监控做了集成功能，第三方工具就可以读取Actuator暴露的接口来收集数据。</p><h4 id="1-1-Spring-Boot-Admin"><a href="#1-1-Spring-Boot-Admin" class="headerlink" title="1.1 Spring Boot Admin"></a>1.1 Spring Boot Admin</h4><p>Spring Boot Admin是一款监控和管理Spring Boot应用程序的开源软件。Spring Boot Admin读取Actuator的接口数据，并通过Spring Boot Admin UI将实时数据展示在前端。了解Spring Boot Admin的配置方法，可以参考我之前的博文<a href="http://t.cn/ExXldWJ">《Spring Boot(四)之程序性能监控》</a></p><p>Actuator提供的监控数据多而全，基本能覆盖日常的监控需求。</p><h4 id="1-2-JVM工具及付费JVM工具"><a href="#1-2-JVM工具及付费JVM工具" class="headerlink" title="1.2 JVM工具及付费JVM工具"></a>1.2 JVM工具及付费JVM工具</h4><p>JDK一般都自带了一些JVM分析工具，像JConsole、JMap、VisualVM等，可以在本地直接读取进程信息并展示。</p><p>还有一些第三方的JVM分析工具，比如阿里开源的<a href="https://alibaba.github.io/arthas/">Arthas</a>，可以对你的Java程序进行诊断。还有诸如<a href="https://www.oneapm.com/">OneAPM</a>等公司，提供了整体的端到端性能诊断解决方案。</p><p>JVM工具，更多的是用来分析JVM Heap信息、内存快照等，可以用来做基本的内存溢出和性能优化的诊断。</p><h4 id="1-3-日志分析"><a href="#1-3-日志分析" class="headerlink" title="1.3 日志分析"></a>1.3 日志分析</h4><p>log日志，也是我们监控系统、排查问题的主要信息来源。在微服务架构体系下，一个痛点就是日志的聚合和链路追踪：即在分布式部署下，一个工程通常需要部署在几十个甚至上百个节点中，这时候，如何收集各个服务器的日志并快速定位是哪台机器出的问题，这是目前Spring Boot应用程序分布式部署的难点。</p><p>Spring Cloud提供了Sleuth组件，可以解决上面的这个问题，具体的实现步骤，可以参考我的博文<a href="https://zhaoyh.com.cn/2018/12/11/Spring-Cloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E6%9C%8D%E5%8A%A1Sleuth/">《Spring Cloud之分布式链路跟踪服务Sleuth》</a></p><h3 id="2-系统间链路监控"><a href="#2-系统间链路监控" class="headerlink" title="2. 系统间链路监控"></a>2. 系统间链路监控</h3><p>由于我们的微服务都是分布式部署的，这就产生了对调用链的监控需求。什么是分布式服务调用链呢，假设用户访问一个资源，请求首先到网关(Nginx或Zuul)A这里，A转发请求到服务B，B又通过HTTP或RPC调用服务C，则此时就产生了一个简单的分布式调用链：A-&gt;B-&gt;C。分布式调用链的监控，主要关注服务调用层级关系、调用链出错比例、调用链吞吐、请求响应时间等信息。</p><h4 id="2-1-HTTP调用"><a href="#2-1-HTTP调用" class="headerlink" title="2.1 HTTP调用"></a>2.1 HTTP调用</h4><p>对于服务间采用HTTP治理的分布式系统来说，调用链可以参考之前的博文<a href="https://zhaoyh.com.cn/2018/12/11/Spring-Cloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E6%9C%8D%E5%8A%A1Sleuth/">《Spring Cloud之分布式链路跟踪服务Sleuth》</a> 和第二篇<a href="https://zhaoyh.com.cn/2018/12/26/Spring-Cloud%E4%B9%8BZipkin%E9%93%BE%E8%B7%AF%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/">《Spring Cloud之基于Zipkin的链路数据持久化》</a></p><h4 id="2-2-RPC服务调用"><a href="#2-2-RPC服务调用" class="headerlink" title="2.2 RPC服务调用"></a>2.2 RPC服务调用</h4><p>通用的RPC框架，都会提供自己的监控组件，你可以根据你选择的RPC框架选择对应的RPC监控。例如我们目前的服务采用Spring Boot + Dubbo的方式开发，使用的RPC监控组件就是<a href="https://github.com/apache/incubator-dubbo-admin">Dubbo Admin</a>。Dubbo Admin目前提供了如下的服务监控页面：</p><p><img src="https://static.zhaoyh.com.cn/1552981396996.jpg" alt="image"></p><p><img src="https://static.zhaoyh.com.cn/1552981344475.jpg" alt="image"></p><p>提供了服务提供者、消费者、调用关系、响应时间等指标信息。</p><h3 id="3-监控数据存储及展示"><a href="#3-监控数据存储及展示" class="headerlink" title="3. 监控数据存储及展示"></a>3. 监控数据存储及展示</h3><p>使用Spring Boot Admin做监控，有一个痛点是其只展示了实时的metrics信息，并不具备存储监控数据的功能，如果我们需要做数据的时间序列分析，就需要借助其他组件。接下来，我提供了一种基于Actuator+Prometheus+Grafana的监控数据展示方案。</p><h4 id="3-1-Prometheus"><a href="#3-1-Prometheus" class="headerlink" title="3.1 Prometheus"></a>3.1 Prometheus</h4><p><a href="https://prometheus.io/">Prometheus</a>是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开发，是Google BorgMon监控系统的开源版本。Prometheus具有如下几个特点：</p><ul><li>多维度数据模型。</li><li>通过HTTP的Pull方式采集时序数据。</li><li>可以配置服务发现来发现监控对象。</li><li>支持多种数据查询，可以对接Grafana。</li></ul><p>Prometheus的整体架构可参考下图：</p><p><img src="https://static.zhaoyh.com.cn/prometheus-arch.png" alt="image"></p><p>Prometheus+Grafana的工作流程大约是这样：</p><ol><li>应用程序暴露metrics接口。</li><li>Prometheus定时抓取metrics指标信息。</li><li>Prometheus存储、整理、清洗指标数据。</li><li>Grafana读取Prometheus的API，数据展示。</li></ol><p>Prometheus的安装过程可直接在官网查找，本文不再赘述。</p><h4 id="3-2-应用程序修改"><a href="#3-2-应用程序修改" class="headerlink" title="3.2 应用程序修改"></a>3.2 应用程序修改</h4><p>增加依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile(&#x27;io.micrometer:micrometer-registry-prometheus:1.0.9&#x27;)</span><br><span class="line">compile(&#x27;io.micrometer:micrometer-spring-legacy:1.0.9&#x27;)</span><br></pre></td></tr></table></figure><p>增加metrics配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.MeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.spring.autoconfigure.MeterRegistryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhaoyh on 2019-03-12</span></span><br><span class="line"><span class="comment"> * micrometer+prometheus配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterRegistryCustomizer <span class="title function_">meterRegistryCustomizer</span><span class="params">(MeterRegistry meterRegistry)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> meterRegistry1 -&gt; &#123;</span><br><span class="line">            meterRegistry.config()</span><br><span class="line">                    .commonTags(<span class="string">&quot;application&quot;</span>, <span class="string">&quot;你的程序名称&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打开 http:&#x2F;&#x2F;程序host:port&#x2F;prometheus ，即可查看相关metrics指标数据。</p><h4 id="3-3-Grafana"><a href="#3-3-Grafana" class="headerlink" title="3.3 Grafana"></a>3.3 Grafana</h4><p><a href="https://grafana.com/">Grafana</a>是一个跨平台的开源度量分析和可视化工具，通过将采集的数据查询然后做可视化的展示，并具备一定的报警功能。Grafana具备如下特点：</p><ul><li>比较灵活的图标展示方式。</li><li>支持Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch等多数据源。</li><li>可配置的报警功能。</li><li>支持多数据源联合查询。</li></ul><p>Grafana的安装可<a href="https://grafana.com/grafana/download/">参考这里</a>。</p><p>Grafana中添加Prometheus数据源的步骤可<a href="http://docs.grafana.org/features/datasources/prometheus/">参考这里</a>。</p><p>Grafana有两种方式创建监控的Dashboard，第一种是自定义Dashboard，第二种是直接使用<a href="https://grafana.com/dashboards">Dashboard模版</a>。</p><p>Grafana中展示到的Spring Boot应用程序的时序数据如下图：</p><p><img src="https://static.zhaoyh.com.cn/1552984912811.jpg" alt="image"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>本文，介绍了对应用程序监控的解决方案，也算是笔者实际应用的一个总结，也欢迎业余时间有兴趣做服务监控的小伙伴多多交流。</p><blockquote><p>以上内容就是关于Spring Cloud之应用程序多维度监控解决方案的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用微服务框架开发应用程序，其特点是分模块、跨进程、分布式部署。这就增加了对整个服务的监控难度，由于分布式服务的“雪崩式效应”，当一个微服务发生故障时，会连带着对整个服务造成不可估量的影响。因此如何快速定位问题，以及查询系统健康程度等就显得尤为必要。系统内及系统间的监控，也是微服务治理的重要组成部分。本文从系统级别和系统间的级别角度，通过笔者在实际生产环境中的应用经验，总结了对Spring Boot应用程序的监控整体多维度解决方案。本文适合Spring Boot开发人员阅读，也适合运维相关的同学阅读，如果你对程序本身的监控感兴趣，也可以尝试去阅读。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Cloud" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Cloud/"/>
    
    
    <category term="服务监控" scheme="http://blog.zhaoyh.com.cn/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot(六)之基于Redis实现MyBatis查询缓存解决方案</title>
    <link href="http://blog.zhaoyh.com.cn/2019/01/24/Spring%20Boot(%E5%85%AD)%E4%B9%8B%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0MyBatis%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.zhaoyh.com.cn/2019/01/24/Spring%20Boot(%E5%85%AD)%E4%B9%8B%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0MyBatis%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2019-01-24T08:11:55.000Z</published>
    <updated>2023-06-07T00:55:37.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>MyBatis是Java中常用的数据层ORM框架，笔者目前在实际的开发中，也在使用MyBatis。本文主要介绍了MyBatis的缓存策略、以及基于SpringBoot和Redis实现MyBatis的二级缓存的过程。实现本文的demo，主要依赖以下软件版本信息，但是由于数据层面的实现，并不依赖具体的版本，你可以以自己主机当前的环境创建。</p><table><thead><tr><th>软件环境</th><th>版本</th></tr></thead><tbody><tr><td>SpringBoot</td><td>1.5.18</td></tr><tr><td>Redis</td><td>通用</td></tr><tr><td>MyBatis</td><td>3.4.+</td></tr></tbody></table><span id="more"></span><h3 id="2-MyBatis缓存策略"><a href="#2-MyBatis缓存策略" class="headerlink" title="2. MyBatis缓存策略"></a>2. MyBatis缓存策略</h3><h4 id="2-1-一级缓存"><a href="#2-1-一级缓存" class="headerlink" title="2.1 一级缓存"></a>2.1 一级缓存</h4><p>MyBatis默认实现了一级缓存，实现过程可参考下图：<br><img src="https://static.zhaoyh.com.cn/1548298183815.jpg" alt="image"></p><p>默认基础接口有两个：</p><ul><li>org.apache.ibatis.session.SqlSession: 提供了用户和数据库交互需要的所有方法，默认实现类是DefaultSqlSession。</li><li>org.apache.ibatis.executor.Executor: 和数据库的实际操作接口，基础抽象类BaseExecutor。</li></ul><p>我们从底层往上查看源代码，首先打开BaseExecutor的源代码，可以看到Executor实现一级缓存的成员变量是PerpetualCache对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(BaseExecutor.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Transaction transaction;</span><br><span class="line">  <span class="keyword">protected</span> Executor wrapper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line">  <span class="comment">// 实现一级缓存的成员变量</span></span><br><span class="line">  <span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">  <span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br><span class="line">  <span class="keyword">protected</span> Configuration configuration;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们再打开PerpetualCache类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerpetualCache</span> <span class="keyword">implements</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PerpetualCache</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>可以看到PerpetualCache是对Cache的基本实现，而且通过内部持有一个简单的HashMap实现缓存。</p><p>了解了一级缓存的实现后，我们再回到入口处，为了你的sql语句和数据库交互，MyBatis首先需要实现SqlSession，通过DefaultSqlSessionFactory实现SqlSession的初始化的过程可查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">  <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">// Executor初始化</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，通过configuration创建一个Executor，实际创建Executor的过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">  executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否开启二级缓存</span></span><br><span class="line">  <span class="comment">// 如果开启，使用CahingExecutor装饰BaseExecutor的子类</span></span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，cacheEnabled字段是二级缓存是否开启的标志位，如果开启，会使用使用CahingExecutor装饰BaseExecutor的子类。</p><p>创建完SqlSession，根据Statment的不同，会使用不同的SqlSession查询方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>SqlSession把具体的查询职责委托给了Executor，如果只开启了一级缓存的话，首先会进入BaseExecutor的query方法。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 使用缓存</span></span><br><span class="line">    list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      <span class="comment">// 清空缓存</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>query方法实现了缓存的查询过程，在query方法执行的最后，会判断一级缓存级别是否是STATEMENT级别，如果是的话，就清空缓存，这也就是STATEMENT级别的一级缓存无法共享localCache的原因。</p><p>SqlSession的insert方法和delete方法，都会统一走update的流程，在BaseExecutor实现的update方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空缓存</span></span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，每次执行update方法都会执行clearLocalCache清空缓存。至此，我们分析完了MyBatis的一级缓存从入口到实现的过程。</p><p>关于MyBatis一级缓存的总结：</p><ul><li>一级缓存的生命周期和SqlSession保持一致；</li><li>一级缓存的缓存通过HashMap实现；</li><li>一级缓存的作用域是对应的SqlSession，假如存在多个SqlSession，写操作可能会引起脏数据。</li></ul><h4 id="2-2-二级缓存"><a href="#2-2-二级缓存" class="headerlink" title="2.2 二级缓存"></a>2.2 二级缓存</h4><p>在上一小节中，我们知道一级缓存的的作用域就是对应的SqlSession。若开启了二级缓存，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，二级缓存的查询流程如图所示：<br><img src="https://static.zhaoyh.com.cn/1548298759229.jpg" alt="image"><br>二级缓存开启后，同一个namespace下的所有数据库操作语句，都使用同一个Cache，即二级缓存结果会被被多个SqlSession共享，是一个全局的变量。当开启二级缓存后，数据查询的执行流程就是二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>二级缓的实现源码，可以查看CachingExecutor类的query方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 从MappedStatement中获得在配置初始化时赋予的Cache</span></span><br><span class="line">  <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要刷新缓存</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 主要是用来处理存储过程的</span></span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">// 尝试从tcm中获取缓存的列表，会把获取值的职责一路传递</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">        list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二级缓存查询结束后，就会进入一级缓存的执行流程，可参考上一小节内容。</p><p>关于二级缓存的总结：</p><ul><li>二级缓存是SqlSession之间共享，能够做到mapper级别，并通过Cache实现缓存。</li><li>由于MyBatis的缓存都是内存级的，在分布式环境下，有可能会产生脏数据，因此可以考虑使用第三方存储组件，如Redis实现二级缓存的存储，这样的安全性和性能也会更高。</li></ul><h3 id="3-SpringBoot和Redis实现MyBatis二级缓存"><a href="#3-SpringBoot和Redis实现MyBatis二级缓存" class="headerlink" title="3. SpringBoot和Redis实现MyBatis二级缓存"></a>3. SpringBoot和Redis实现MyBatis二级缓存</h3><p>MyBatis的默认实现一级缓存的，二级缓存也是默认保存在内存中，因此当分布式部署你的应用时，有可能会产生脏数据。通用的解决方案是找第三方存储缓存结果，比如Ehcache、Redis、Memcached等。接下来，我们介绍下，使用Redis作为缓存组件，实现MyBatis二级缓存。</p><p>在实现二级缓存之前，我们假设你已经实现了SpringBoot+MyBatis的构建过程，如果还没有，建议你先创建一个demo实现简单的CRUD过程，然后再查看本文解决二级缓存的问题。</p><h4 id="3-1-增加Redis配置"><a href="#3-1-增加Redis配置" class="headerlink" title="3.1 增加Redis配置"></a>3.1 增加Redis配置</h4><p>首先在你的工程加入Redis依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(&#x27;org.springframework.boot:spring-boot-starter-data-redis&#x27;)</span><br></pre></td></tr></table></figure><p>我使用的gradle，使用maven的同学可对应查询即可！</p><p>其次在配置文件中加入Redis的链接配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.cluster.nodes=XXX:port,YYY:port</span><br></pre></td></tr></table></figure><p>这里我们使用的是Redis集群配置。</p><p>打开mybatis.xml配置文件，开启二级缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><p>增加Redis的配置类，开启json的序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhaoyh on 2019-01-23</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写Redis序列化方式，使用Json方式:</span></span><br><span class="line"><span class="comment">     * 当我们的数据存储到Redis的时候，我们的键（key）和值（value）都是通过Spring提供的Serializer序列化到数据库的。RedisTemplate默认使用的是JdkSerializationRedisSerializer，StringRedisTemplate默认使用的是StringRedisSerializer。</span></span><br><span class="line"><span class="comment">     * Spring Data JPA为我们提供了下面的Serializer：</span></span><br><span class="line"><span class="comment">     * GenericToStringSerializer、Jackson2JsonRedisSerializer、JacksonJsonRedisSerializer、JdkSerializationRedisSerializer、OxmSerializer、StringRedisSerializer。</span></span><br><span class="line"><span class="comment">     * 在此我们将自己配置RedisTemplate并定义Serializer。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置值（value）的序列化采用Jackson2JsonRedisSerializer。</span></span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 设置键（key）的序列化采用StringRedisSerializer。</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-实现MyBatis的Cache接口"><a href="#3-2-实现MyBatis的Cache接口" class="headerlink" title="3.2 实现MyBatis的Cache接口"></a>3.2 实现MyBatis的Cache接口</h4><p>org.apache.ibatis.cache.Cache接口是MyBatis通用的缓存实现接口，包括一级缓存和二级缓存都是基于Cache接口实现缓存机制。</p><p>创建MybatisRedisCache类，实现Cache接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhaoyh on 2019-01-22</span></span><br><span class="line"><span class="comment"> * MyBatis二级缓存配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisRedisCache</span> <span class="keyword">implements</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(MybatisRedisCache.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认redis有效期</span></span><br><span class="line"><span class="comment">     * 单位分钟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_REDIS_EXPIRE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入redis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cache id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MybatisRedisCache</span><span class="params">(<span class="keyword">final</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == id) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;MybatisRedisCache Instance Require An Id...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">&quot;MybatisRedisCache: &quot;</span> + id);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The identifier of this cache</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   Can be any object but usually it is a &#123;<span class="doctag">@link</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value The result of a select.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != value) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;putObject key: &quot;</span> + key.toString());</span><br><span class="line">            <span class="comment">// 向Redis中添加数据，默认有效时间是2小时</span></span><br><span class="line">            redisTemplate.opsForValue().set(key.toString(), value, DEFAULT_REDIS_EXPIRE, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The object stored in the cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != key) &#123;</span><br><span class="line">                LOG.info(<span class="string">&quot;getObject key: &quot;</span> + key.toString());</span><br><span class="line">                <span class="keyword">return</span> redisTemplate.opsForValue().get(key.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;getFromRedis: &quot;</span> + key.toString() + <span class="string">&quot; failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">&quot;getObject null...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * As of 3.3.0 this method is only called during a rollback</span></span><br><span class="line"><span class="comment">     * for any previous value that was missing in the cache.</span></span><br><span class="line"><span class="comment">     * This lets any blocking cache to release the lock that</span></span><br><span class="line"><span class="comment">     * may have previously put on the key.</span></span><br><span class="line"><span class="comment">     * A blocking cache puts a lock when a value is null</span></span><br><span class="line"><span class="comment">     * and releases it when the value is back again.</span></span><br><span class="line"><span class="comment">     * This way other threads will wait for the value to be</span></span><br><span class="line"><span class="comment">     * available instead of hitting the database.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 删除缓存中的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyObject The key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Not used</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">removeObject</span><span class="params">(Object keyObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != keyObject) &#123;</span><br><span class="line">            redisTemplate.delete(keyObject.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears this cache instance</span></span><br><span class="line"><span class="comment">     * 有delete、update、insert操作时执行此函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;clear...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;*:&quot;</span> + <span class="built_in">this</span>.id + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            LOG.info(<span class="string">&quot;keys size: &quot;</span> + keys.size());</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                LOG.info(<span class="string">&quot;key : &quot;</span> + key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(keys)) &#123;</span><br><span class="line">                redisTemplate.delete(keys);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;clear failed!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Optional. This method is not called by the core.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The number of elements stored in the cache (not its capacity).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> (Long) redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">RedisCallback</span>&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Long <span class="title function_">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.dbSize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LOG.info(<span class="string">&quot;getSize: &quot;</span> + size.intValue());</span><br><span class="line">        <span class="keyword">return</span> size.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Optional. As of 3.2.6 this method is no longer called by the core.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Any locking needed by the cache must be provided internally by the cache provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A ReadWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReadWriteLock <span class="title function_">getReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.readWriteLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setRedisTemplate</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        MybatisRedisCache.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于redisTemplate是类变量，需要手动注入，再创建一个配置类注入redisTemplate即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhaoyh on 2019-01-22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入redis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisTemplate</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        MybatisRedisCache.setRedisTemplate(redisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-mapper文件中加入二级缓存的声明"><a href="#3-3-mapper文件中加入二级缓存的声明" class="headerlink" title="3.3 mapper文件中加入二级缓存的声明"></a>3.3 mapper文件中加入二级缓存的声明</h4><p>在任意需要开启二级缓存的mapper配置文件中，加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapper开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;XX.XX.MybatisRedisCache&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义回收的策略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;eviction&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一定时间自动刷新缓存，单位是毫秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;flushInterval&quot;</span> <span class="attr">value</span>=<span class="string">&quot;600000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最多缓存对象的个数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否只读，若配置可读写，则需要对应的实体类能够序列化 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此，就完成了基于Redis的MyBatis二级缓存的配置。</p><h3 id="4-FAQ"><a href="#4-FAQ" class="headerlink" title="4. FAQ"></a>4. FAQ</h3><ul><li>二级缓存相比较于一级缓存来说，粒度更细，但是也会更不可控，安全使用二级缓存的条件很难。</li><li>二级缓存非常适合查询热度高且更新频率低的数据，请谨慎使用。</li><li>建议在生产环境下关闭二级缓存，使得MyBatis单纯作为ORM框架即可，缓存使用其他更安全的策略。</li></ul><blockquote><p>以上内容就是关于SpringBoot基于Redis实现MyBatis查询缓存解决方案的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;MyBatis是Java中常用的数据层ORM框架，笔者目前在实际的开发中，也在使用MyBatis。本文主要介绍了MyBatis的缓存策略、以及基于SpringBoot和Redis实现MyBatis的二级缓存的过程。实现本文的demo，主要依赖以下软件版本信息，但是由于数据层面的实现，并不依赖具体的版本，你可以以自己主机当前的环境创建。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件环境&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;SpringBoot&lt;/td&gt;
&lt;td&gt;1.5.18&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Redis&lt;/td&gt;
&lt;td&gt;通用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MyBatis&lt;/td&gt;
&lt;td&gt;3.4.+&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Boot/"/>
    
    
    <category term="Redis" scheme="http://blog.zhaoyh.com.cn/tags/Redis/"/>
    
    <category term="Spring Boot" scheme="http://blog.zhaoyh.com.cn/tags/Spring-Boot/"/>
    
    <category term="MyBatis" scheme="http://blog.zhaoyh.com.cn/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud之基于Zipkin的链路数据持久化</title>
    <link href="http://blog.zhaoyh.com.cn/2018/12/26/Spring-Cloud%E4%B9%8BZipkin%E9%93%BE%E8%B7%AF%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>http://blog.zhaoyh.com.cn/2018/12/26/Spring-Cloud%E4%B9%8BZipkin%E9%93%BE%E8%B7%AF%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</id>
    <published>2018-12-26T08:53:05.000Z</published>
    <updated>2023-06-07T00:55:37.995Z</updated>
    
    <content type="html"><![CDATA[<p>在前文<a href="https://zhaoyh.com.cn/2018/12/11/Spring-Cloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E6%9C%8D%E5%8A%A1Sleuth/">《Spring Cloud之分布式链路跟踪服务Sleuth》</a>中我们介绍了如何对微服务做分布式链路数据的跟踪。但是目前仍存在一个问题：Zipkin-Server默认是把链路数据保存的内存中，当积累的数据过多后，会存在内存溢出的风险。因此本文着重解决这个问题，介绍了一种基于Spring Cloud Sleuth + RabbitMQ + ElasticSearch的数据持久化存储解决方案。</p><span id="more"></span><h3 id="1-改造Zipkin-Server"><a href="#1-改造Zipkin-Server" class="headerlink" title="1. 改造Zipkin Server"></a>1. 改造Zipkin Server</h3><p>我们假设你已经按照前文<a href="https://zhaoyh.com.cn/2018/12/11/Spring-Cloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E6%9C%8D%E5%8A%A1Sleuth/">《Spring Cloud之分布式链路跟踪服务Sleuth》</a>的步骤，实现了Zipkin链路数据通过RabbitMQ传输。首先对于你的Zipkin Server服务，加入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-sleuth-zipkin-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-storage-elasticsearch-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.24.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件中加入以下ElasticSearch的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#zipkin数据持久化</span><br><span class="line">zipkin.storage.type=elasticsearch</span><br><span class="line">zipkin.storage.elasticsearch.hosts=es的IP:端口</span><br><span class="line">zipkin.storage.elasticsearch.max-requests=64</span><br><span class="line">#注意索引就用zipkin即可</span><br><span class="line">zipkin.storage.elasticsearch.index=zipkin</span><br><span class="line">zipkin.storage.elasticsearch.index-shards=5</span><br><span class="line">zipkin.storage.elasticsearch.index-replicas=1</span><br></pre></td></tr></table></figure><p>然后重启Zipkin Server即可，查看你的ElasticSearch，会发现多了zipkin-YYYY-MM-DD的索引数据，调用链路的数据也会正常的显示。</p><h3 id="2-配置Zipkin-Dependencies"><a href="#2-配置Zipkin-Dependencies" class="headerlink" title="2. 配置Zipkin Dependencies"></a>2. 配置Zipkin Dependencies</h3><p>别高兴的太早，如果你查看Zipkin的依赖分析，会发现没有依赖关系的数据：<br><img src="https://static.zhaoyh.com.cn/1545813668015.jpg" alt="image"><br>这是因为es中只存储了链路的调用数据，还没有计算依赖关系，所以需要一个Zipkin提供的插件来计算依赖关系，根据<a href="https://github.com/openzipkin/zipkin-dependencies">openzipkin</a>中的介绍，首先下载jar包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O zipkin-dependencies.jar &#x27;https://search.maven.org/remote_content?g=io.zipkin.dependencies&amp;a=zipkin-dependencies&amp;v=LATEST&#x27;</span><br></pre></td></tr></table></figure><p>计算依赖关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STORAGE_TYPE=elasticsearch ES_HOSTS=http://es的IP:端口 java -jar zipkin-dependencies-2.0.4.jar</span><br></pre></td></tr></table></figure><p>稍等片刻，插件会把依赖关系的数据计算好：<br><img src="https://static.zhaoyh.com.cn/1545814127954.jpg" alt="image"></p><p>此时，再打开Zipkin Server的管理页面，会发现依赖分析页面已经有数据了：<br><img src="https://static.zhaoyh.com.cn/1545814262487.jpg" alt="image"></p><p>对于生产环境来说，可以写一个定时任务，执行依赖分析的计算插件。</p><blockquote><p>以上内容就是关于Spring Cloud之Zipkin链路数据持久化策略的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前文&lt;a href=&quot;https://zhaoyh.com.cn/2018/12/11/Spring-Cloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E6%9C%8D%E5%8A%A1Sleuth/&quot;&gt;《Spring Cloud之分布式链路跟踪服务Sleuth》&lt;/a&gt;中我们介绍了如何对微服务做分布式链路数据的跟踪。但是目前仍存在一个问题：Zipkin-Server默认是把链路数据保存的内存中，当积累的数据过多后，会存在内存溢出的风险。因此本文着重解决这个问题，介绍了一种基于Spring Cloud Sleuth + RabbitMQ + ElasticSearch的数据持久化存储解决方案。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Cloud" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Cloud/"/>
    
    
    <category term="RabbitMQ" scheme="http://blog.zhaoyh.com.cn/tags/RabbitMQ/"/>
    
    <category term="Sleuth" scheme="http://blog.zhaoyh.com.cn/tags/Sleuth/"/>
    
    <category term="Zipkin" scheme="http://blog.zhaoyh.com.cn/tags/Zipkin/"/>
    
    <category term="ElasticSearch" scheme="http://blog.zhaoyh.com.cn/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud之分布式链路跟踪服务Sleuth</title>
    <link href="http://blog.zhaoyh.com.cn/2018/12/11/Spring-Cloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E6%9C%8D%E5%8A%A1Sleuth/"/>
    <id>http://blog.zhaoyh.com.cn/2018/12/11/Spring-Cloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E6%9C%8D%E5%8A%A1Sleuth/</id>
    <published>2018-12-11T04:06:08.000Z</published>
    <updated>2023-06-07T00:55:37.977Z</updated>
    
    <content type="html"><![CDATA[<p>随着你的微服务部署节点的增多，以及对各个微服务的拆分后，对服务本身的日志和调用链路的监控就变得越来越难。这就需要一个能快速定位分布式系统下问题的需求，Spring Cloud Sleuth就是为了解决分布式链路追踪这个问题而产生的。</p><p>目前业界比较优秀的分布式链路追踪产品如Google的Dapper，Twitter的Zipkin，阿里的“鹰眼”，大众点评的CAT等。</p><p>本文主要讲述如何在Spring Cloud Sleuth中集成Zipkin，实现对微服务的日志跟踪和分布式链路的调用监控及展示。</p><span id="more"></span><h3 id="1-Spring-Cloud-Sleuth介绍"><a href="#1-Spring-Cloud-Sleuth介绍" class="headerlink" title="1. Spring Cloud Sleuth介绍"></a>1. Spring Cloud Sleuth介绍</h3><blockquote><p>Spring Cloud Sleuth implements a distributed tracing solution for Spring Cloud.</p></blockquote><p>Spring Cloud Sleuth的实体概念主要来源于谷歌在2010年发表的一篇论文：<a href="https://ai.google/research/pubs/pub36356">《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》</a>：</p><ul><li>Span: 基本工作单元，发送一个远程调用(RPC)就会产生一个新的Span，Span是一个64位ID唯一的，Trace是用另一个64位ID唯一标记的，Span还有其他数据信息比如摘要、时间戳事件、Span的ID、以及进程ID。</li><li>Trace: A set of spans forming a tree-like structure. For example, if you are running a distributed big-data store, a trace might be formed by a put request.</li><li>Annotation: 用来记录事件，cs - Client Sent，sr - Server Received，ss - Server Sent，cr - Client Received。</li></ul><p>以Twitter的Zipkin为例，其Span和Trace在分布式系统中的概念体现如下图所示：<br><img src="https://static.zhaoyh.com.cn/sleuth-trace-id.png" alt="image"></p><p>Spring Cloud Sleuth的官方文档可参考：<a href="https://spring.io/projects/spring-cloud-sleuth">Spring Cloud Sleuth</a>。</p><h3 id="2-微服务日志追踪"><a href="#2-微服务日志追踪" class="headerlink" title="2. 微服务日志追踪"></a>2. 微服务日志追踪</h3><h4 id="2-1-日志输出"><a href="#2-1-日志输出" class="headerlink" title="2.1 日志输出"></a>2.1 日志输出</h4><p>对一个普通的基础SpringBoot的项目来说，如果你没有实现自定义的logback.xml，默认打印的日志格式可如下图所示：<br><img src="https://static.zhaoyh.com.cn/1544415084355.jpg" alt="image"></p><p>若想实现Spring Cloud Sleuth的日志跟踪服务，只需要在你的Spring Cloud的项目pom文件中加上依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在配置文件application或bootstrap中加上配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.zipkin.service.name=your-log-name</span><br></pre></td></tr></table></figure><p>此时日志格式就如下图：<br><img src="https://static.zhaoyh.com.cn/1544415795878.jpg" alt="image"></p><p>此时log会比之前多了sleuth的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zhaoyh-log,888114b702f9c3aa,888114b702f9c3aa,true]</span><br></pre></td></tr></table></figure><p>这四段内容分别是：</p><ul><li>serviceName: 你指定的sleuth的service, the name of the application that logged the span.</li><li>traceId: the id of the latency graph that contains the span.</li><li>spanId: the id of a specific operation.</li><li>exportable: whether the log should be exported to Zipkin or not.</li></ul><h4 id="2-2-日志收集"><a href="#2-2-日志收集" class="headerlink" title="2.2 日志收集"></a>2.2 日志收集</h4><p>假如你正在ELK框架治理你的日志，可以修改logstash的parse脚本处理日志：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">       # pattern matching logback pattern</span><br><span class="line">       grok &#123;</span><br><span class="line">              match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;TIMESTAMP_ISO8601:timestamp&#125;\s+%&#123;LOGLEVEL:severity&#125;\s+\[%&#123;DATA:service&#125;,%&#123;DATA:trace&#125;,%&#123;DATA:span&#125;,%&#123;DATA:exportable&#125;\]\s+%&#123;DATA:pid&#125;\s+---\s+\[%&#123;DATA:thread&#125;\]\s+%&#123;DATA:class&#125;\s+:\s+%&#123;GREEDYDATA:rest&#125;&quot; &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在网页调试grok脚本的有效性，可参考<a href="https://grokdebug.herokuapp.com/">Grok Debugger</a>。</p><h3 id="3-分布式链路追踪"><a href="#3-分布式链路追踪" class="headerlink" title="3. 分布式链路追踪"></a>3. 分布式链路追踪</h3><p>本文介绍分布式链路追踪是以Spring Cloud Sleuth集成Zipkin服务为基础，为此，一共需要准备4个微服务工程，点击可直接查看代码：</p><ul><li><a href="https://github.com/chadwick521/springboot-eureka-server">eureka server</a>: 负责服务注册。</li><li><a href="https://github.com/chadwick521/springcloud-zipkin-server">zipkin server</a>: 负责链路数据收集及查询。</li><li><a href="https://code.aliyun.com/zhaoyh_code/springcloud-zuul.git">zuul-gatewat</a>: 服务网关，负责调用。</li><li><a href="https://github.com/chadwick521/springboot-loadbalance-client">my-service</a>: 后台server，负责调用。</li></ul><h4 id="3-1-启动eureka-server"><a href="#3-1-启动eureka-server" class="headerlink" title="3.1 启动eureka server"></a>3.1 启动eureka server</h4><p>首先启动一个eureka server的服务，如果你不明白这是什么意思，那么我建议你从头开始再学习一遍Spring Boot和Spring Cloud的基础哈！</p><h4 id="3-2-启动zipkin-server"><a href="#3-2-启动zipkin-server" class="headerlink" title="3.2 启动zipkin server"></a>3.2 启动zipkin server</h4><p>有三种方式启动一个Zipkin Server，第一种是自己基于Spring Cloud创建一个工程，加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用注解，启动Zipkin Server 服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableZipkinServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringcloudZipkinServerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringcloudZipkinServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是使用docker，首先拉取公共镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull openzipkin/zipkin</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9411:9411 --name zipkin openzipkin/zipkin</span><br></pre></td></tr></table></figure><p>第三种是通过Zipkin官方脚本下载zipkin的jar包直接运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://zipkin.io/quickstart.sh | bash -s</span><br><span class="line">java -jar zipkin.jar</span><br></pre></td></tr></table></figure><p>查看本地的Zipkin Server的页面 <a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a> 如下图所示：<br><img src="https://static.zhaoyh.com.cn/1544424790737.jpg" alt="image"></p><h4 id="3-3-构建zuul-gateway服务"><a href="#3-3-构建zuul-gateway服务" class="headerlink" title="3.3 构建zuul-gateway服务"></a>3.3 构建zuul-gateway服务</h4><p>构建基于zuul的网管服务可参考之前的博文：<a href="https://zhaoyh.com.cn/2018/03/12/Spring%20Cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3Zuul/">Spring Cloud微服务框架之服务网关Zuul</a>，再做相应的修改即可，首先pom中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Cloud应用在检测到依赖有sleuth和zipkin后，会自动在调用过程中向HTTP请求注入追踪信息，并向Zipkin Server发送这些信息。同时配置文件中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#zipkin</span><br><span class="line">spring.zipkin.service.name=zuul-gateway</span><br><span class="line">spring.zipkin.base-url=http://localhost:9411</span><br><span class="line">spring.sleuth.sampler.percentage=1.0</span><br></pre></td></tr></table></figure><p>spring.zipkin.service.name指定了此追踪的名称，spring.zipkin.base-url指定了Zipkin Server的地址，spring.sleuth.sampler.percentage将采样比例设置为1.0，即全部都需要，所设置的值介于0.0到1.0之间，对应不同的比例。</p><p>同时配置文件中加入需要调用的my-service服务的路由地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#zuul-serviceId</span><br><span class="line">zuul.routes.client.path=/client/**</span><br><span class="line">zuul.routes.client.serviceId=MY-SERVICE-TEST</span><br></pre></td></tr></table></figure><p>启动zuul-gate服务，端口为15050，同时，对与my-service项目，也是跟zuul同样的修改方式，并加入一个返回服务的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/api/testZuul&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testZuul</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;zuul-&gt;client: &quot;</span> + port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动my-service。</p><h4 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h4><p>浏览器输入：<a href="http://localhost:15050/client/api/testZuul">http://localhost:15050/client/api/testZuul</a> ，此时就由zuul-gateway调用了my-service的服务。此时查看zipkin server，搜索到一条记录：<br><img src="https://static.zhaoyh.com.cn/1544427846854.jpg" alt="image"></p><p>点击记录，可以看到这次请求在每个微服务耗费的时间：<br><img src="https://static.zhaoyh.com.cn/1544428364820.jpg" alt="image"></p><p>点击依赖分析按钮，可以查看服务的依赖关系，在本案例中，zuul-gateway将请求转发到了my-service，它们的依赖关系如图：</p><p><img src="https://static.zhaoyh.com.cn/1544428480192.jpg" alt="image"></p><h3 id="4-Spring-Cloud-Sleuth进阶"><a href="#4-Spring-Cloud-Sleuth进阶" class="headerlink" title="4. Spring Cloud Sleuth进阶"></a>4. Spring Cloud Sleuth进阶</h3><p>在前两节，我们介绍了分布式链路跟踪服务的基本应用，这对生产级别来说还不够用，接下来，我们继续深入Sleuth，讲述使用消息队列来传输链路数据，并对链路数据的持久化做个探究。</p><h4 id="4-1-使用消息队列RabbitMQ传递链路数据"><a href="#4-1-使用消息队列RabbitMQ传递链路数据" class="headerlink" title="4.1 使用消息队列RabbitMQ传递链路数据"></a>4.1 使用消息队列RabbitMQ传递链路数据</h4><p>在第三节中，Zipkin Server收集到的数据，是zuul-gateway和my-service通过http传输的。Spring Cloud Sleuth支持消息中间件来通信，我们可以直接通过RabbitMQ，来实现各个服务和Zipkin Server的通信。首先在Zipkin Server中加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-sleuth-zipkin-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件中加入RabbitMQ的链接配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.addresses=IP:5672</span><br><span class="line">spring.rabbitmq.username=XX</span><br><span class="line">spring.rabbitmq.password=XXXXX</span><br></pre></td></tr></table></figure><p>替换启动类的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableZipkinStreamServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringcloudZipkinServerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(SpringcloudZipkinServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其他的各个微服务来说，只需要加入依赖和RabbitMQ的链接配置即可，这样就能将链路监控数据上传方式从http修改为消息组件RabbitMQ。</p><h4 id="4-2-链路数据持久化策略"><a href="#4-2-链路数据持久化策略" class="headerlink" title="4.2 链路数据持久化策略"></a>4.2 链路数据持久化策略</h4><p>在前述的所有例子中，Zipkin Server是将链路数据存储在内存中，一旦重启，之前的链路数据全部丢失。Zipkin支持将链路数据持久化存储在MySQL、ElasticSearch、Cassandra等。在生产环境下，可以根据需要和存储条件，合理的将数据持久化，本文由于篇幅有限，就不再详细展示持久化存储的配置过程。</p><h3 id="5-主要参考文档"><a href="#5-主要参考文档" class="headerlink" title="5. 主要参考文档"></a>5. 主要参考文档</h3><ol><li><a href="https://cloud.spring.io/spring-cloud-sleuth/1.3.x/single/spring-cloud-sleuth.html">https://cloud.spring.io/spring-cloud-sleuth/1.3.x/single/spring-cloud-sleuth.html</a></li><li><a href="https://www.e4developer.com/2018/02/09/tracing-messages-in-choreography-with-sleuth-and-zipkin/">Tracing messages in Choreography with Sleuth and Zipkin</a></li><li><a href="https://ai.google/research/pubs/pub36356">Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</a></li></ol><blockquote><p>以上内容就是关于Spring Cloud之分布式链路跟踪服务Sleuth的全部内容了，谢谢你阅读到了这里！</p></blockquote><blockquote><p>Author:zhaoyh</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着你的微服务部署节点的增多，以及对各个微服务的拆分后，对服务本身的日志和调用链路的监控就变得越来越难。这就需要一个能快速定位分布式系统下问题的需求，Spring Cloud Sleuth就是为了解决分布式链路追踪这个问题而产生的。&lt;/p&gt;
&lt;p&gt;目前业界比较优秀的分布式链路追踪产品如Google的Dapper，Twitter的Zipkin，阿里的“鹰眼”，大众点评的CAT等。&lt;/p&gt;
&lt;p&gt;本文主要讲述如何在Spring Cloud Sleuth中集成Zipkin，实现对微服务的日志跟踪和分布式链路的调用监控及展示。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Cloud" scheme="http://blog.zhaoyh.com.cn/categories/Spring-Cloud/"/>
    
    
    <category term="RabbitMQ" scheme="http://blog.zhaoyh.com.cn/tags/RabbitMQ/"/>
    
    <category term="Sleuth" scheme="http://blog.zhaoyh.com.cn/tags/Sleuth/"/>
    
    <category term="Zipkin" scheme="http://blog.zhaoyh.com.cn/tags/Zipkin/"/>
    
  </entry>
  
</feed>
